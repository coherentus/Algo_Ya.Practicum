# https://contest.yandex.ru/contest/25070/run-report/69474998/
# Задача B. Железные дороги.
#
# В стране есть n городов, которым присвоены номера от 1 до n.
# Между городами проложены дороги. От каждого к каждому.
# Дороги двух разных видов. Задаются строками символов 'B' и 'R'.
# Необходимо определить, является ли данная карта дорог
# 'оптимальной', то есть:
# не существует пары городов A и B такой, что от A до B
# можно добраться как по дорогам типа R, так и по дорогам типа B.
# Иными словами, для любой пары городов верно,
# что от города с меньшим номером до города с бОльшим номером
# можно добраться по дорогам только какого-то одного типа
# или же что маршрут построить вообще нельзя.
#
#
# -- ПРИНЦИП РАБОТЫ --
# Задачу возможно решить с помощью графа. Если принять виды рёбер за
# разные направления, то она сведётся к определению наличия цикла.
# Для хранения графа используется матрица смежности. Во-первых, формат
# ввода представляет собой практически матрицу смежности, во-вторых,
# граф полный и поэтому использование матрицы смежности вполне оправдано.
# Граф используется направленный, рёбра типа 'B' принимаются направленными от
# вершины с меньшим номером к вершине с большим номером, а рёбра типа 'R',
# соответственно, направленными от вершины с большим номером к меньшему.
# Тогда, если между какими-либо двумя вершинами будут найдены как нисходящий
# так и восходящий маршруты, то выполнится условие 'неоптимальности карты'
# по заданию. Данный факт обнаруживает обход графа DFS (в глубину).
# Ни сам цикл, ни пару вершин определять по условию не требуется.
#
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Для обхода в глубину используется приём с раскраской вершин в три цвета, по
# по статусу их обработанности.
# Изначально все вершины белые, то есть не посещённые. При первом обращении к
# вершине (заходу в вершину), она красится в серый цвет (обретает статус
# 'в обработке'), когда 'серая' вершина извлекается из стека, то её обработка
# закончена, вершина красится в чёрный цвет, что означает статус 'обработана'.
# Процесс обработки вершины заключается в добавлении в стек её смежных вершин.
# При этом цвет добавляемых вершин может быть белым, серым или чёрным. Белая
# добавляется, чёрная нет, а серый цвет означает, что вершина уже находится в
# в обработке и эта ситуация сигнализирует о наличии цикла в графе.
#
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность состоит из:
# a) На этапе ввода
# - O(∣V∣) инициализация массива для хранения вершин. V - кол-во вершин.
# - O(∣V∣) внесение информации в массив вершин. V - кол-во вершин.
# б) На этапе работы алгоритма
# - O(∣V∣⋅∣V∣), где V - кол-во вершин графа.
# Итоговая сложность - 2⋅O(∣V∣) + O(∣V∣⋅∣V∣), или O(∣V∣)⋅(1 + O(∣V∣)),
# или O(∣V∣**2),
# где V - кол-во вершин графа.
# Пространственная сложность складывается из:
# - O(∣V∣**2) - для хранения матрицы смежности. V - кол-во вершин.
# - O(∣V∣) - для хранения массива цветов.  V - кол-во вершин.
# Итоговая сложность также O(∣V∣**2), где V - кол-во вершин.
SYMB_B = 'B'
RIGHT_RESULT = 'YES'
WRONG_RESULT = 'NO'


def input_line(index, town_arr, in_line):
    """Занести данные в матрицу смежности.

    Args:
        index (int:): номер вершины, для которой переданы данные
        town_arr (list[list[int:]]): матрица вершин, размер больше на 1,
            чтобы номер вершины использовать как индекс, т.е. нулевые
            индексы не используются.
        in_line (str:): строка символов, первый относится к вершине с
            номером index + 1
    Return:
        None. Изменяет переданный аргумент town_arr.

    Граф создаётся направленным.
    Значение 'B' считается прямым направлением, т.е. от меньшего номера
    вершины к большему. Вводятся значением '1' в строку матрицы.
    Значение 'R' - обратным, т.е. от большего номера вершины к меньшему.
    Вводятся значением '1' в столбец матрицы.
    """
    # Карта задана n-1 строкой.
    # В i-й строке описаны дороги из города i в города i+1, i+2, ..., n.
    # В строке записано n - i символов, каждый из которых либо R, либо B.
    # Если j-й символ строки i равен «B»,
    # то из города i в город i + j идет дорога типа «B».
    # Аналогично для типа «R».
    chars_in_line = enumerate(in_line, start=index+1)
    for char_num, char in chars_in_line:
        if char == SYMB_B:
            town_arr[index][char_num] = True
        else:
            town_arr[char_num][index] = True


def check_optimum(towns_arr):
    """Определить 'оптимальность' карты, вернуть результат.

    Args:
        towns_arr list[list[Union[None, True]]]: массив вершин,
    Return:
        result str: результат работы алгоритма, 'YES' или 'NO'.

    Граф передан матрицей смежности.
    DFS-обход организуется с покраской вершин. Если будет найден цикл, то
    прекратить работу и вернуть "NO". Иначе вернуть "YES".
    """
    optimum = RIGHT_RESULT  # заготовка ответа
    colors = ['white' for _ in range(len(towns_arr))]
    # цикл MainDFS():
    for i in range(1, len(towns_arr)):
        # Перебираем варианты стартовых вершин, пока они существуют.
        if colors[i] == 'white':
            start_vert = i
            # Основной DFS
            stack = []
            stack.append(start_vert)
            while stack:
                # Получаем из стека очередную вершину.
                # Это может быть как новая вершина,
                # так и уже посещённая однажды.
                cur_vert = stack.pop()
                if colors[cur_vert] == 'white':
                    # Красим вершину в серый. И сразу
                    # кладём её обратно в стек.
                    colors[cur_vert] = 'gray'
                    stack.append(cur_vert)
                    # Теперь добавляем в стек все непосещённые смежные вершины.
                    # строка матрицы смежности c номером вершины содержит
                    # True в позиции смежной вершины.
                    # [Union(None, True),...] True в положении idx означает
                    # наличие ребра из текущей вершины в вершину с номером idx
                    matrix_str = towns_arr[cur_vert]
                    for idx in range(1, len(towns_arr)):
                        if matrix_str[idx]:
                            # idx - номер смежной вершины
                            if colors[idx] == 'white':
                                stack.append(idx)
                            elif colors[idx] == 'gray':  # есть цикл
                                optimum = WRONG_RESULT
                                break

                elif colors[cur_vert] == 'gray':
                    # Серую вершину мы могли получить из стека
                    # только на обратном пути.
                    # Следовательно, её следует перекрасить в чёрный.
                    colors[cur_vert] = 'black'
    return optimum


def main():
    """Ввести данные, вызвать обработку, напечатать результат."""
    # ввод данных
    with open('input.txt') as file_in:
        # кол-во городов
        num_towns = int(file_in.readline())
        # матрица смежности
        towns = [
            [None for _ in range(num_towns + 1)]
            for __ in range(num_towns + 1)
        ]

        # считывание и обработка дорог
        for town_count in range(1, num_towns):
            input_line(town_count, towns, file_in.readline().strip())
        file_in.close()

    print(check_optimum(towns))


if __name__ == '__main__':
    main()
