# https://contest.yandex.ru/contest/25070/run-report/69494605/
# Задача А. Найти вес максимального остовного дерева.
#
# Взвешенный ненаправленный граф задаётся набором рёбер.
# В графе могут быть петли и кратные рёбра. Также нет гарантии,
# что граф связный.
# Задание состоит в том, чтобы найти и распечатать вес максимального
# остовного дерева. Если это невозможно, то распечатать предопределённое
# текстовое сообщение.
#
# Формат ввода
# В первой строке дано количество вершин n и ребер m графа
# (1 ≤ n ≤ 1000, 0 ≤ m ≤ 100000).
# В каждой из следующих m строк заданы рёбра в виде троек чисел u, v, w.
# u и v — вершины, которые соединяет это ребро. w — его вес
# ( 1 ≤ u, v ≤ n, 0 ≤ w ≤ 10000).
#
# -- ПРИНЦИП РАБОТЫ --
# Построение максимального остовного дерева в решении данной задачи основано
# на алгоритме Прима. Суть его сводится к тому, что на каждом шаге, пока не
# добавлены все вершины, в дерево добавляется максимальное по весу ребро, одна
# вершина которого уже в остове, а другая нет. Затем в остов добавляется эта
# вершина, а инцидентные ей рёбра, не инцидентные вершинам из остова,
# добавляются во временный набор рёбер. Из этого набора рёбер-кандидатов на
# попадание в остов и выбираются максимальные рёбра.
# Для реализации такого набора рёбер использована очередь с приоритетом
# PriorityQueue из пакета queue.
#
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Алгоритм Прима по поиску минимального остова описан на странице теории:
# https://practicum.yandex.ru/learn/algorithms/courses/7f101a83-9539-4599-b6e8-8645c3f31fad/sprints/33729/topics/45179065-a73b-473d-94d1-24774573f266/lessons/adb9a06e-f8a5-4d9b-b88a-2085cc8458f9/
# Если при использовании этого алгоритма подбирать рёбра не минимального, а
# а максимального веса, то результатом его работы будет максимальное остовное
# дерево.
# Чтобы использовать приоритетную очередь на минимум PriorityQueue в качестве
# очереди на максимум, необходимо как-то инвертировать вес эл-тов очереди так,
# чтобы минимальный эл-т из алгоритма в очередь попадал как максимальный
# и наоборот.
# По условию, 0 <= вес рёбер <= 10000, тогда при домножении веса ребра на -1,
# значения весов выстроятся в обратном порядке и их можно будет использовать
# в очереди PriorityQueue.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность состоит из:
# a) На этапе ввода
# - O(∣V∣) инициализация массива для хранения вершин. V - кол-во вершин.
# - O(∣E∣) внесение информации в массив вершин. Е - кол-во рёбер.
# б) На этапе работы алгоритма
# - O(∣V∣⋅log∣E∣), где E - кол-во рёбер, а V - кол-во вершин графа.
# В алгоритме Прима применена очередь с приоритетом для хранения рёбер,
# операции извлечения и записи которой работают за O(N), при N эл-тах.
# Итоговая сложность - O(∣V∣) + O(∣E∣) + O(∣E∣⋅log∣V∣).
# Пространственная сложность складывается из:
# - O(∣V∣⋅∣E∣) - в худшем случае, для хранения графа,
# - O(∣V∣) - для хранения множества вершин,
# - O(∣E∣) - для хранения промежуточного списка рёбер,
# где  E - кол-во рёбер, а V - кол-во вершин графа.
# Итоговая сложность - O(∣V∣⋅∣E∣) + O(∣V∣) + O(∣E∣).
from queue import PriorityQueue


ERROR_MESSAGE = 'Oops! I did it again'


def edge_input(vert_arr, edge_line):
    """По условию добавить данные в список вершин.

    Args:
        vert_arr (list(dict(int:key: int:value))): массив вершин,
            индекс это номер вершины, словарь - инцидентные рёбра,
            ключ - номер смежной вершины, а значение - вес.
        edge_line (str): строка ввода, содержит три значения.

    В графе могут быть петли и кратные рёбра. Для поиска остовного
    дерева в них нет надобности. Петли просто игнорятся, а из
    кратных рёбер остаётся с наибольшим весом.

    Фунция изменяет данные в переданном массиве, ничего не возвращает.
    """
    # вершины, соединяемые ребром и вес этого ребра
    vert_1, vert_2, weight = map(int, edge_line.split())

    if not vert_1 == vert_2:  # отброс петель
        # граф ненаправленный, поэтому данные ребра добавляются в обе вершины
        # если вершина уже упоминалась, то это кратное ребро, обновить
        # значение веса, если он больше

        # ин-фа для первой о второй
        cur_vert: dict = vert_arr[vert_1]
        if cur_vert.setdefault(vert_2, weight) <= weight:
            cur_vert[vert_2] = weight
            # ин-фа для второй о первой
            vert_arr[vert_2][vert_1] = weight


def max_weight(vertexs_full):
    """Найти максимальное остовное дерево. Вернуть его вес.

    Args:
        vertexs_full [
            {vert_number: weight, ...},
        ]
        Индекс эл-та это номер вершины, к которой относится словарь.
        Ключ словаря это номер смежной вершины, значение - вес.
        Размер списка на единицу больше кол-ва вершин для удобства
        нумерации, т.е. нулевой эл-т не используется.
        Все ключи и значения типа int(целые числа).

    Return:
        Суммарный вес максимального остовного дерева графа,
        если оно существует, или сообщение об ошибке.

    Остовное дерево ищется по алгоритму Прима.
    Берётся первая вершина. В набор потенциальных рёбер добавляются
    все её рёбра. Вершина добавляется в дерево, из просматриваемых удаляется.
    Далее, пока набор потенциальных рёбер не пуст и есть недобавленные
    в остов вершины, циклично производится набор действий:
    из набора рёбер изымается ребро максимального веса. Вершина "стартовая"
    уже находится в остове. Если вторая вершина ещё не в остове, то вес ребра
    добавляется в сумму весов, а инцидентные ей, второй вершине, рёбра
    добавляются в набор, но с условием, что другая вершина ещё не в остове.

    Если набор потенциальных рёбер исчерпан, а недобавленные вершины ещё есть,
    то граф несвязный, возвращается ошибка.
    Если же удалось добавить все вершины, то граф связный, а для построения
    максимального остовного дерева использовано минимально необходимое кол-во
    рёбер максимального веса, возвращается суммарный вес рёбер.
    """
    # Накопитель весов рёбер, составляющие MaxST.
    max_tree_weights: int = 0

    # Множество вершин, уже добавленных в остов.
    vert_in_tree = set()

    # Множество вершин, ещё не добавленных в остов.
    # В графе есть все вершины от 1 до кол-ва вершин
    vert_in_graph = [x for x in range(1, len(vertexs_full))]

    # Промежуточное хранилище для рёбер, потенциально могущих войти в остов.
    # Добавляются в виде (вес, [нач.вершина, кон.вершина]) приоритет - вес.
    potent_edges = PriorityQueue()

    # Из множества вершин графа берём первую.
    v = 1
    vert_in_tree.add(v)
    vert_in_graph.remove(v)

    # рёбра этой вершины добавить в кандидаты на остов.
    # Добавляем все рёбра, которые инцидентны v
    # vertexs[v] - словарь смежных с v вершин {вершина: вес}
    for end_vert, weight in vertexs_full[v].items():
        # пишем в очередь с приоритетом на минимум
        potent_edges.put(
            (-weight, (v, end_vert))
        )

    while (not potent_edges.empty()) and vert_in_graph:
        # взять ребро с максимальным весом
        # (вес, (вершина, вершина))
        # первая вершина уже в остове, вторую проверить
        # ребро учитывается, если вторая вершина не в остове
        cur_edge = potent_edges.get()
        secnd_vert = cur_edge[1][1]
        if secnd_vert not in vert_in_tree:
            max_tree_weights -= cur_edge[0]
            vert_in_tree.add(secnd_vert)
            vert_in_graph.remove(secnd_vert)
            for end_vert, weight in vertexs_full[secnd_vert].items():
                # пишем в очередь с приоритетом на минимум
                # только те рёбра, вторая вершина которых ещё не в остове
                if end_vert not in vert_in_tree:
                    potent_edges.put(
                        (-weight, (secnd_vert, end_vert))
                    )

    if vert_in_graph:
        return ERROR_MESSAGE
    else:
        return max_tree_weights


def main():
    """Ввести данные, вызвать обработку, напечатать результат.

    Граф вводится в структуру вида:
    vertexs = [
        {vert_number: weight, ...},
    ]
    Индекс эл-та это номер вершины, к которой относится словарь.
    Ключ словаря это номер смежной вершины, значение - вес.
    Размер списка на единицу больше кол-ва вершин для удобства
    нумерации, т.е. нулевой эл-т не используется.
    """
    # ввод данных
    with open('input.txt') as file_in:
        # кол-во вершин и рёбер
        num_vert, num_edg = map(int, file_in.readline().split())

        # для графа из одной вершины
        if num_vert == 1:
            print('0')
            return

        # если есть признак несвязности графа
        if num_vert - num_edg > 1:
            print(ERROR_MESSAGE)
            return

        vertexs = [dict() for _ in range(num_vert + 1)]
        # считывание и обработка рёбер
        for _ in range(num_edg):
            edge_input(vertexs, file_in.readline())
        file_in.close()

    print(max_weight(vertexs))


if __name__ == '__main__':
    main()
