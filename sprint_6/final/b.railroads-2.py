# https://contest.yandex.ru/contest/25070/run-report/69506840/
# Задача B. Железные дороги.
#
# В стране есть n городов, которым присвоены номера от 1 до n.
# Между городами проложены дороги. От каждого к каждому.
# Дороги двух разных видов. Задаются строками символов 'B' и 'R'.
# Необходимо определить, является ли данная карта дорог
# 'оптимальной', то есть:
# не существует пары городов A и B такой, что от A до B
# можно добраться как по дорогам типа R, так и по дорогам типа B.
# Иными словами, для любой пары городов верно,
# что от города с меньшим номером до города с бОльшим номером
# можно добраться по дорогам только какого-то одного типа
# или же что маршрут построить вообще нельзя.
#
#
# -- ПРИНЦИП РАБОТЫ --
# Задачу возможно решить с помощью графа.
# Города - вершины, дороги - рёбра.
# Из условия очевидно, что для 'оптимальности' карты между двумя
# вершинами должны существовать маршруты из рёбер только одного типа.
# Из описания формата ввода ясно, что граф полный, то есть, каждая
# вершина связана с каждой, или, другими словами, от каждой
# вершины до любой другой вершины кратчайший путь - это одно ребро.
# Следовательно, если найдутся маршруты между двумя вершинами
# с длиной более одного ребра, то для условия 'оптимальности' карты
# они должны состоять из рёбер того-же типа, что ребро, инцидентное
# обеим этим вершинам.
# У графа из двух вершин таковое ребро всего одно и карта дорог всегда
# оптимальна.
# Для графа из трёх вершин с рёбрами одинакового типа карта также
# оптимальна. Если рёбра графа из трёх вершин описать в формате ввода
# задачи как:
# BR
# B
# то путь 1->2->3 будет состоять из рёбер 'B', а 1->3 из ребра 'R',
# что нарушит оптимальность карты дорог.
# Далее при увеличени количества вершин ничего принципиально не
# изменится. Увеличится лишь количество вариантов маршрутов.
# Более строго, для 'неоптимальности' карты дорог необходимо
# и достаточно, чтобы в графе нашлись две вершины с номерами i и i+N,
# такие, что маршрут i->i+N состоит из ребра одного типа, а маршрут
# из i в i+N через подмножество вершин с номерами между i и i+N состоит
# из рёбер другого типа и этот маршрут проходит через вершины в порядке
# возрастания номеров.
# Выделив подграф, содержащий эти два маршрута и составляющие их вершины,
# можно в нём обнаружить следующее свойство:
# - обход в глубину по одному типу ребёр даст один из маршрутов.
# Если теперь вместо принятого направления рёбер от меньшего номера вершины
# к большему, напрвлением считать тип рёбер, то окажется, что обход в глубину
# сначала по одному маршруту(по одному типу рёбер) пройдёт в одном направлении
# от вершины i к i+N(или от i+N к i), а затем по другому маршруту(по другому
# типу рёбер) вернётся в исходную вершину. Если этот обход не прервать, то он
# зациклится.
# На основе этих соображений строится решение задачи, а именно:
# - Входные данные вносятся в ориентированный граф. Рёбра типа 'B' считаются
# направленными из вершин с меньшими номерами, а рёбра типа 'R' - наоборот.
# Для хранения графа используется список смежности, реализованный на
# стандартном списке Python. Эл-т списка - словарь Python, индекс эл-та - это
# номер вершины, которую описывает словарь. Для каждой смежной вершины
# создаётся ключ из её номера и значением 'True'.
# - После получения с ввода всего графа запускается обход в глубину с первой
# вершины. Если в процессе обхода обнаруживается цикл, то выдаётся сообщение
# о 'неоптимальности' карты дорог.
#
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Для обхода в глубину используется приём с раскраской вершин в три цвета, по
# по статусу их обработанности.
# Изначально все вершины белые, то есть не посещённые. При первом обращении к
# вершине (заходу в вершину), она красится в серый цвет (обретает статус
# 'в обработке'), когда 'серая' вершина извлекается из стека, то её обработка
# закончена, вершина красится в чёрный цвет, что означает статус 'обработана'.
# Процесс обработки вершины заключается в добавлении в стек её смежных вершин.
# При этом цвет добавляемых вершин может быть белым, серым или чёрным. Белая
# добавляется, чёрная нет, а серый цвет означает, что вершина уже находится в
# в обработке и эта ситуация сигнализирует о наличии цикла в графе.
#
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность состоит из:
# a) На этапе ввода
# - O(∣V∣) инициализация массива для хранения вершин. V - кол-во вершин.
# - O(∣V∣) внесение информации в массив вершин. V - кол-во вершин.
# б) На этапе работы алгоритма
# - O(∣V∣⋅∣V∣), где V - кол-во вершин графа.
# Итоговая сложность - 2⋅O(∣V∣) + O(∣V∣⋅∣V∣), или O(∣V∣)⋅(1 + O(∣V∣)),
# или O(∣V∣**2),
# где V - кол-во вершин графа.
# Пространственная сложность складывается из:
# - O(∣V∣**2) - для хранения матрицы смежности. V - кол-во вершин.
# - O(∣V∣) - для хранения массива цветов.  V - кол-во вершин.
# Итоговая сложность также O(∣V∣**2), где V - кол-во вершин.
SYMB_B = 'B'
RIGHT_RESULT = 'YES'
WRONG_RESULT = 'NO'


def input_line(index, town_arr, in_line):
    """Занести данные в матрицу смежности.

    Args:
        index (int:): номер вершины, для которой переданы данные
        town_arr (list[list[int:]]): матрица вершин, размер больше на 1,
            чтобы номер вершины использовать как индекс, т.е. нулевые
            индексы не используются.
        in_line (str:): строка символов, первый относится к вершине с
            номером index + 1
    Return:
        None. Изменяет переданный аргумент town_arr.

    Граф создаётся направленным.
    Значение 'B' считается прямым направлением, т.е. от меньшего номера
    вершины к большему. Вводятся созданием ключа из номера вершины
    и значением True в эл-т списка с индексом index.
    Значение 'R' - обратным, т.е. от большего номера вершины к меньшему.
    Вводятся созданием ключа из номера вершины
    и значением True в эл-т списка с индексом, вычисляемым из переданного
    index и относительного номера символа в строке.
    """
    # Карта задана n-1 строкой.
    # В i-й строке описаны дороги из города i в города i+1, i+2, ..., n.
    # В строке записано n - i символов, каждый из которых либо R, либо B.
    # Если j-й символ строки i равен «B»,
    # то из города i в город i + j идет дорога типа «B».
    # Аналогично для типа «R».
    chars_in_line = enumerate(in_line, start=index+1)
    for char_num, char in chars_in_line:
        if char == SYMB_B:
            town_arr[index][char_num] = True
        else:
            town_arr[char_num][index] = True


def check_optimum(towns_arr):
    """Определить 'оптимальность' карты, вернуть результат.

    Args:
        towns_arr list[dict[int: bool]]: массив вершин
    Return:
        result str: результат работы алгоритма, 'YES' или 'NO'.

    Ориентированный граф передан списком смежности. По индексу эл-та словарь
    со смежными вершинами той, чей номер равен индексу.
    Наличие ключа - существование ребра.
    DFS-обход организуется с покраской вершин. Если будет найден цикл, то
    прекратить работу и вернуть "NO". Иначе вернуть "YES".
    """
    optimum = RIGHT_RESULT  # заготовка ответа
    colors = ['white' for _ in range(len(towns_arr))]
    # цикл MainDFS():
    for i in range(1, len(towns_arr)):
        # Перебираем варианты стартовых вершин, пока они существуют.
        if colors[i] == 'white':
            start_vert = i
            # Основной DFS
            stack = [start_vert]
            while stack:
                # Получаем из стека очередную вершину.
                # Это может быть как новая вершина,
                # так и уже посещённая однажды.
                cur_vert = stack.pop()
                if colors[cur_vert] == 'white':
                    # Красим вершину в серый. И сразу
                    # кладём её обратно в стек.
                    colors[cur_vert] = 'gray'
                    stack.append(cur_vert)
                    # Теперь добавляем в стек все непосещённые смежные вершины.
                    # строка матрицы смежности c номером вершины содержит
                    # True в позиции смежной вершины.
                    # [Union(None, True),...] True в положении idx означает
                    # наличие ребра из текущей вершины в вершину с номером idx
                    for idx in towns_arr[cur_vert]:
                        # idx - номер смежной вершины
                        if colors[idx] == 'white':
                            stack.append(idx)
                        elif colors[idx] == 'gray':  # есть цикл
                            optimum = WRONG_RESULT
                            break

                elif colors[cur_vert] == 'gray':
                    # Серую вершину мы могли получить из стека
                    # только на обратном пути.
                    # Следовательно, её следует перекрасить в чёрный.
                    colors[cur_vert] = 'black'
    return optimum


def main():
    """Ввести данные, вызвать обработку, напечатать результат."""
    # ввод данных
    with open('input.txt') as file_in:
        # кол-во городов
        num_towns = int(file_in.readline())
        # cписок смежности в виде списка словарей.
        # индекс эл-та - номер стартовой вершины,
        # ключ словаря, если есть, номер смежной вершины,
        # значение - True
        towns = [dict() for _ in range(num_towns + 1)]

        # считывание и обработка дорог
        for town_count in range(1, num_towns):
            input_line(town_count, towns, file_in.readline().strip())
        file_in.close()

    print(check_optimum(towns))


if __name__ == '__main__':
    main()
