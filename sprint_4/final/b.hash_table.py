# Задача А. Поисковая система.
# Суть задания:
# Написать реализацию хеш-таблицы.
# Хеш-таблица должна поддерживать следующие операции:
#
# put key value —– добавить значение по ключу. Если ключ есть, то обновить.
# get key –— вывести значение по ключу. Если ключа нет, то вывести «None».
# delete key –— удалить ключа из таблицы. Если ключа нет, то вывести «None».
#
# Требования к реализации:
#
# Нельзя использовать имеющийся тип данных dict в Python.
# Число хранимых в таблице ключей не превосходит 10^5.
# Разрешать коллизии следует с помощью метода цепочек
# или с помощью открытой адресации.
# Все операции должны выполняться за O(1) в среднем.
# Поддерживать рехеширование и масштабирование хеш-таблицы не требуется.
# Ключи и значения, id сотрудников и их зарплата, —– целые числа.
# Поддерживать произвольные хешируемые типы не требуется.
#
# # -- ПРИНЦИП РАБОТЫ --
# Выбрана реализация с классовым подходом. Он даёт более наглядный,
# поддерживаемый и структурированный код.
# Класс Node вспомогательный, на нём построены структуры типа связный
# список, адресуемые эл-тами основного класса хеш-таблицы.
#
# Класс HashTable представляет собой набор из приватного атрибута __items
# и методов: приватного __get_hash и публичных getitem, setitem и delitem.
#
# Атрибут __items стандартного типа list хранит головные эл-ты связных
# списков, которые в свою очередь предназначены для разрешения коллизий.
# Атрибут value создаваемого эл-та связного списка представляет собой список
# из двух эл-тов ключ-значение.
# При создании экземпляра класса HashTable создаётся единоразово объёмом
# равным запрошеннму размеру. Значения инициализируются «None».
#
# Метод __get_hash - вычисление хеша для запрошенного ключа. Возвращаемое
# значение типа int используется в методах манипулирования данными
# как идекс в приватном атрибуте __items.
#
# Метод getitem - выдача значения по ключу, если ключа нет - выдача «None».
# Алгоритм:
# - методом __get_hash получить индекс эл-та в массиве __items.
# - принять головой связного списка эл-т __items по этому индексу.
# - перебором связного списка искать пару ключ-значение.
# - если найдена - вернуть значение.
# - если список кончился - вернуть «None».
#
# Метод setitem - запись значения по ключу. Возврат значения не требуется.
# Алгоритм:
# - методом __get_hash получить индекс эл-та в массиве __items.
# - принять головой связного списка эл-т __items по этому индексу.
# - если для этого эл-та __items ещё не создан связный список (признак
# этого - значение «None» в __items[h]), то создать объект Node c входной
# парой ключ-значение, записать этот экземпляр в __items[h],
# завершить обработку.
# - перебором связного списка искать входную пару ключ-значение.
# Если найдена, то в текущем эл-те связного списка обновить значение
# в атрибуте .value, завершить обработку.
# Проверить, является ли текущй эл-т связного списка последним (признак
# последнего эл-та - значение «None» в атрибуте .next). Если эл-т последний,
# создать экземпляр Node c входной парой ключ-значение, записать ссылку на
# него в атрибут .next текущего эл-та связного списка, завершить обработку.
#
# Метод delitem - удаление ключа. Если ключ есть, то вернуть значение,
# иначе вернуть «None».
# Алгоритм:
# - методом __get_hash получить индекс эл-та в массиве __items.
# - если для этого эл-та __items ещё не создан связный список (признак
# этого - значение «None» в __items[h]), то вернуть «None»,
# завершить обработку.
# - завести prev_node - вспомогательную переменную для операции удаления
# эл-та из середины связного списка, приравнять к голове.
# - принять головой связного списка эл-т __items по этому индексу.
# - если в голове найдена входная пара ключ-значение, запомнить значение
# в переменную value, изъять текущую голову из связного списка путём
# присвоения голове ссылки на следующий эл-т, завершить обработку
# вернув value.
# - перебором списка искать входную пару ключ-значение. Если найдена,
# запомнить значение в переменную value, изъять текущий эл-т из связного
# списка путём присвоения атрибуту .next этого эл-та ссылки
# на следующий эл-т.
# Для следующей итерации обновить указатели на текущий и предыдущий эл-ты.
# Если входная пара не найдётся в цикле, то работа метода завершится
# автоматическим возвратом «None».


# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --

from typing import Dict, List, Optional

HASH_TABLE_SIZE = 100000
OPERATIONS_TABLE: Dict[str, str] = {
    'put': 'setitem',
    'get': 'getitem',
    'delete': 'delitem',
}


class Node:
    """Ячейка связного списка.

    Атрибуты:
    value: (Any) - хранимое значение.
    next: (Optional[Node]) - ссылка на следующий элемент.
    """
    def __init__(self, value=None, next=None):
        self.value = value
        if next is not None:
            self.next = next
        else:
            self.next = None


class HashTable:
    """Хеш-таблица. Реализация с ограниченным функционалом.

    Методы:
    - put key value —– добавление пары ключ-значение.
    Если ключ уже есть, то обновить значение.
    - get key –— получение значения по ключу.
    Если ключа нет, то вернуть «None». Иначе вернуть найденное значение.
    - delete key –— удаление ключа.
    Если ключа нет, то вернуть «None». Иначе вернуть найденное значение
    и удалить ключ.
    Число ячеек (bucket) для хранения не превосходит 10^5.
    Разрешение коллизий с помощью метода цепочек.
    Все операции выполняются за O(1) в среднем.
    Рехеширование и масштабирование хеш-таблицы не предусмотрено.
    Ключи и значения —– целые числа.
    """
    def __init__(self, size: int) -> None:
        self.__size: int = size
        self.__items: List[Optional[Node]] = [None] * size

    def getitem(self, key: str) -> Optional[int]:
        """Вернуть значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.

        Returns:
            Optional[str]: Значение, если есть, или None.
        Методом __get_hash получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        Вернуть результат.
        """
        h = self.__get_hash(key)
        node = self.__items[h]  # head of linked list
        while node is not None:
            if node.value[0] == key:
                return node.value[1]
            node = node.next

    def setitem(self, key: str, value: str) -> None:
        """Записать значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.
            value (str): Переданное значение.
        Методом __get_hash получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        Если есть - обновить, иначе - создать.
        """
        h = self.__get_hash(key)
        node = self.__items[h]  # head of linked list
        if node is None:
            node = Node(value=[key, value])
            self.__items[h] = node
            return None

        while node is not None:
            if node.value[0] == key:
                node.value[1] = value
                return None
            if node.next is None:
                node_new = Node(value=[key, value])
                node.next = node_new
                return None
            node = node.next

    def delitem(self, key: str) -> Optional[int]:
        """Удалить значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.

        Returns:
            Optional[str]: Если есть, то значение, или None.
        Методом __get_hash получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        В переменной для возврата сохранить значение или None.
        Если есть ключ удалить соответствующий ему эл-т. Вернуть ответ.
        """
        h = self.__get_hash(key)
        head = self.__items[h]  # head of linked list
        if head is None:
            return None
        prev_node = head
        if head.value[0] == key:
            value = head.value[1]
            self.__items[h] = head.next
            return value

        node = head.next
        while node is not None:
            if node.value[0] == key:
                value = node.value[1]
                prev_node.next = node.next
                return value
            prev_node = node
            node = node.next

    def __get_hash(self, key: str) -> int:
        return int(key) % self.__size


def get_res(table, requ):
    """Вернуть результат действия из запроса."""
    command, *args = requ.split()
    func = getattr(table, OPERATIONS_TABLE[command])
    return func(*args), command


def main():
    hash_table = HashTable(HASH_TABLE_SIZE)
    num_requests = int(input())
    for _ in range(num_requests):
        request = input()
        result, command = get_res(hash_table, request)
        if not command == 'put':
            print(result)


if __name__ == '__main__':
    main()
