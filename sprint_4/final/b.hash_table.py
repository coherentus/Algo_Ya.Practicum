# https://contest.yandex.ru/contest/24414/run-report/66293038/
# Задача А. Поисковая система.
# Суть задания:
# Написать реализацию хеш-таблицы.
# Хеш-таблица должна поддерживать следующие операции:
#
# put key value —– добавить значение по ключу. Если ключ есть, то обновить.
# get key –— вывести значение по ключу. Если ключа нет, то вывести «None».
# delete key –— удалить ключа из таблицы. Если ключа нет, то вывести «None».
#
# Требования к реализации:
#
# Нельзя использовать имеющийся тип данных dict в Python.
# Число хранимых в таблице ключей не превосходит 10^5.
# Разрешать коллизии следует с помощью метода цепочек
# или с помощью открытой адресации.
# Все операции должны выполняться за O(1) в среднем.
# Поддерживать рехеширование и масштабирование хеш-таблицы не требуется.
# Ключи и значения, id сотрудников и их зарплата, —– целые числа.
# Поддерживать произвольные хешируемые типы не требуется.
#
# -- ПРИНЦИП РАБОТЫ --
# Выбрана реализация с классовым подходом. Он даёт более наглядный,
# поддерживаемый и структурированный код.
# Класс Node вспомогательный, на нём построены структуры типа связный
# список, адресуемые эл-тами основного класса хеш-таблицы.
#
# Класс HashTable представляет собой набор из приватного атрибута __items
# и методов: приватного __get_index и публичных getitem, setitem и delitem.
#
# Атрибут __items стандартного типа list хранит головные эл-ты связных
# списков, которые в свою очередь предназначены для разрешения коллизий.
# Атрибут value создаваемого эл-та связного списка представляет собой список
# из двух эл-тов ключ-значение.
# При создании экземпляра класса HashTable создаётся единоразово объёмом
# равным запрошеннму размеру. Значения инициализируются «None».
#
# В методе __get_index - совмещены два действия:
# - вычисление хеша для запрошенного ключа, как целочисленного значения.
# - вычисление индекса эл-та в таблице.
# Для вычисления хеша применён метод умножения. В общих чертах описан
# в теории:
# https://practicum.yandex.ru/learn/algorithms/courses/7f101a83-9539-4599-b6e8-8645c3f31fad/sprints/21362/topics/618173c7-3c0e-4955-b88b-d7146f9ffe2e/lessons/db4e40bc-75c2-4302-95ae-e9cc04f86546/
# Суть в том, что целочисленный ключ умножается на дробную константу.
# Дробная часть находится в диапазоне [0, 1).
# Если её домножить на число корзин M, то она будет в диапазоне [0, M).
# Остаётся отбросить дробную часть.
# Требуемые от хеш-функции качества, как лавинность и равномерность для
# этого метода расчёта хеша зависят от выбора дробной константы. Чтобы
# вычисления проводились быстро, выбрано число близкое к "золотому сечению"
# выраженное целыми числами. Добавив в выражение размер массива, его можно
# преобразовать к виду без деления. Операция битового сдвига использована
# также для ускорения вычисления.
# Возвращаемое методом __get_index значение типа int используется в методах
# манипулирования данными как идекс в приватном атрибуте __items.
#
# Метод get - выдача значения по ключу, если ключа нет - выдача «None».
# Алгоритм:
# - методом __get_index получить индекс эл-та в массиве __items.
# - принять головой связного списка эл-т __items по этому индексу.
# - перебором связного списка искать пару ключ-значение.
# - если найдена - вернуть значение.
# - если список кончился - вернуть «None».
#
# Метод put - запись значения по ключу. Возврат значения не требуется.
# Алгоритм:
# - методом __get_index получить индекс эл-та в массиве __items.
# - принять головой связного списка эл-т __items по этому индексу.
# - если для этого эл-та __items ещё не создан связный список (признак
# этого - значение «None» в __items[h]), то создать объект Node c входной
# парой ключ-значение, записать этот экземпляр в __items[h],
# завершить обработку.
# - перебором связного списка искать входную пару ключ-значение.
# Если найдена, то в текущем эл-те связного списка обновить значение
# в атрибуте .value, завершить обработку.
# Проверить, является ли текущй эл-т связного списка последним (признак
# последнего эл-та - значение «None» в атрибуте .next). Если эл-т последний,
# создать экземпляр Node c входной парой ключ-значение, записать ссылку на
# него в атрибут .next текущего эл-та связного списка, завершить обработку.
#
# Метод delete - удаление ключа. Если ключ есть, то вернуть значение,
# иначе вернуть «None».
# Алгоритм:
# - методом __get_index получить индекс эл-та в массиве __items.
# - если для этого эл-та __items ещё не создан связный список (признак
# этого - значение «None» в __items[h]), то вернуть «None»,
# завершить обработку.
# - завести prev_node - вспомогательную переменную для операции удаления
# эл-та из середины связного списка, приравнять к голове.
# - принять головой связного списка эл-т __items по этому индексу.
# - если в голове найдена входная пара ключ-значение, запомнить значение
# в переменную value, изъять текущую голову из связного списка путём
# присвоения голове ссылки на следующий эл-т, завершить обработку
# вернув value.
# - перебором списка искать входную пару ключ-значение. Если найдена,
# запомнить значение в переменную value, изъять текущий эл-т из связного
# списка путём присвоения атрибуту .next этого эл-та ссылки
# на следующий эл-т.
# Для следующей итерации обновить указатели на текущий и предыдущий эл-ты.
# Если входная пара не найдётся в цикле, то работа метода завершится
# автоматическим возвратом «None».
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Согласно условию задачи о типе ключа, функция хешеривания, получая ключ
# в формате строки, преобразует его в тип целого числа перед обработкой.
# Методы получения, добавления и удаления значения по ключу, а) корректно
# проверяют инициализированность головы связного списка. б) возвращают
# корректные значения сообразно своему функционалу.
# Метод удаления ключа корректно удаляет эл-т связного списка как с головы
# списка, так и из середины и в конце.
#
# -- Оценка сложности --
# Методы записи, получения и удаления значений по ключу в лучшем случае
# имеют сложность O(1), так как размер массива выбран заведомо больше
# кол-ва ключей по заданию. Увеличение сложности возможно при коллизиях.
# В худшем случае сложность может составить O(N), где N - количество
# коллизий для ключа. Специально подобранным набором входных данных этот
# показатель можно довести до M, то есть кол-ва различных ключей, вызывающих
# одинаковый результат работы метода __get_index.
UNDER_GOLDEN_PHI = 2654435769
P_CONST = 17
HASH_TABLE_SIZE = 2 ** P_CONST
BITWISE = 32 - P_CONST


class Node:
    """Ячейка связного списка.

    Атрибуты:
    value: (Any) - хранимое значение.
    next: (Optional[Node]) - ссылка на следующий элемент.
    """
    def __init__(self, value=None, next=None):
        self.value = value
        self.next = next


class HashTable:
    """Хеш-таблица. Реализация с ограниченным функционалом.

    Методы:
    - put key value —– добавление пары ключ-значение.
    Если ключ уже есть, то обновить значение.
    - get key –— получение значения по ключу.
    Если ключа нет, то вернуть «None». Иначе вернуть найденное значение.
    - delete key –— удаление ключа.
    Если ключа нет, то вернуть «None». Иначе вернуть найденное значение
    и удалить ключ.
    Число ячеек (bucket) для хранения не превосходит 10^5.
    Разрешение коллизий с помощью метода цепочек.
    Все операции выполняются за O(1) в среднем.
    Рехеширование и масштабирование хеш-таблицы не предусмотрено.
    Ключи и значения —– целые числа.
    """
    def __init__(self, size):
        self.__items = [None] * size

    def get(self, key):
        """Вернуть значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.

        Returns:
            Optional[str]: Значение, если есть, или None.
        Методом __get_index получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        Вернуть результат.
        """
        idx = self.__get_index(key)
        node = self.__items[idx]  # head of linked list
        while node is not None:
            if node.value[0] == key:
                return node.value[1]
            node = node.next

    def put(self, key, value):
        """Записать значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.
            value (str): Переданное значение.
        Методом __get_index получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        Если есть - обновить, иначе - создать.
        """
        idx = self.__get_index(key)
        node = self.__items[idx]  # head of linked list
        if node is None:
            node = Node(value=[key, value])
            self.__items[idx] = node
            return None

        while node is not None:
            if node.value[0] == key:
                node.value[1] = value
                return None
            if node.next is None:
                node_new = Node(value=[key, value])
                node.next = node_new
                return None
            node = node.next

    def delete(self, key):
        """Удалить значение по ключу.

        Args:
            key (str): Запрашиваемый ключ.

        Returns:
            Optional[str]: Если есть, то значение, или None.
        Методом __get_index получить индекс в массиве данных.
        В эл-те массива определить, есть ли уже значение по ключу.
        В переменной для возврата сохранить значение или None.
        Если есть ключ удалить соответствующий ему эл-т. Вернуть ответ.
        """
        idx = self.__get_index(key)
        head = self.__items[idx]  # head of linked list
        if head is None:
            return None
        prev_node = head
        if head.value[0] == key:
            value = head.value[1]
            self.__items[idx] = head.next
            return value

        node = head.next
        while node is not None:
            if node.value[0] == key:
                value = node.value[1]
                prev_node.next = node.next
                return value
            prev_node = node
            node = node.next

    def __get_index(self, key: str) -> int:
        return ((int(key) * UNDER_GOLDEN_PHI) >> BITWISE) % HASH_TABLE_SIZE


def get_res(table, requ):
    """Вернуть результат действия из запроса."""
    command, *args = requ.split()
    func = getattr(table, command)
    return func(*args), command


def main():
    hash_table = HashTable(HASH_TABLE_SIZE)
    num_requests = int(input())
    for _ in range(num_requests):
        request = input()
        result, command = get_res(hash_table, request)
        if not command == 'put':
            print(result)


if __name__ == '__main__':
    main()
