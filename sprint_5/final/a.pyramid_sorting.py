# Задача Б. Быстрая ортировка 'на месте' (in-place quick sort).
# Необходимо реализовать рекурсивный алгоритм быстрой сортировки
# без использования дополнительной памяти.
#
# Сортируемые эл-ты состоят из трёх раличных значений. Строки и двух чисел.
# Строка означает логин, а числа - кол-во решённых задач и штраф.
# Приоритеты сортировки:
# 1. кол-во решённых задач. По убыванию, т.е. на первом месте - max.
# 2. для равных п.1 штраф вступает в сортировку. По возрастанию, min выше.
# 3. для равных п.2 логин вступает в сортировку. По алфавиту из строчных
# латинских букв.
#
# Формат ввода
# В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
# В каждой из следующих n строк задана информация про одного из участников.
# i-й участник описывается тремя параметрами:
#
# уникальным логином (строкой из маленьких латинских букв длиной до 20)
# числом решённых задач Pi
# штрафом Fi
# Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10**9.
# Формат вывода
# Для отсортированного списка участников вывести по порядку их логины
# по одному в строке.
#
# -- ПРИНЦИП РАБОТЫ --
# В Python есть встроенная операция сравнения однотипных списков,
# числа сравниваются как обычно, а строки лексикографически посимвольно.
# 1. Чтобы воспользоваться операцией сравнения необходимо на этапе ввода
# определённым образом сформировать исходный массив:
# строка на входе
# логин           баллы за задачи         баллы штрафа
#
# в массив попадает в виде
# points                          penalty                 name
# int((баллы за задачи) * -1)     int(баллы штрафа)       логин
#
# В таком виде введённые данные позволяют использовать операцию сравнения
# для оговоренной в задании логикой сортировки.
# 2. Сама сортировка.
# Алгоритм рекурсивной функции следующий:
# На входе массив (ссылка на него) и начальный и конечный индексы.
# 1. Проверка базового случая. Если наступил - возврат из функции.
# 2. Выбор опорного эл-та (pivot). Берётся значение эл-та из середины
# диапазона, заданного входными знчениями left right.
# 3. Создание левого и правого указателей left_idx right_idx. С их помощью
# будут сравниваться и меняться местами эл-ты.
# 4. Запуск переборки эл-тов.
# Пока левый и правый указатели не встретятся производятся переборы значений
# слева и справа от опорного.
# С левого края (от меньших индексов) вправо последовательно сравниваются
# значения эл-тов с опорным. Если найден эл-т больше опорного, он становится
# кандидатом на перемещение в правую часть. Перебор приостанавливается.
# С правого края (от больших индексов) влево последовательно сравниваются
# значения эл-тов с опорным. Если найден эл-т меньше опорного, он становится
# кандидатом на перемещение в левую часть. Перебор приостанавливается.
# По остановке обоих указателей возможны три варианта:
# а) Кандидатов не нашлось. Левый и правый указатели равны.
# Передаче в следующие итерации подлежат отрезки
# [left, right_idx] и [left_idx, right]. Проверка (left_idx <= right_idx)
# отсекает перемещение эл-тов и закрывает цикл переборки указателей.
# б) С обеих сторон нашлись кандидаты. Левый и правый указатели указывают
# на них. Следует поменять значения кандидатов местами.
# Проверка (left_idx <= right_idx) запускает это действие. После этого
# циклы поиска кандидатов продолжаются.
# в) Кандидат нашёлся только с одной стороны. Указатели указывают, один на
# кандидата, второй на pivot. Необходимо поменять местами значения pivot и
# кандидата. Проверка (left_idx <= right_idx) запускает это действие.
# После этого циклы поиска кандидатов продолжаются.
#
# 3. Вывод результата.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Согласно условию задания рекурсивная функция сортировки на каждой итерации
# вызывается с аргументами из индексов во внешнем для неё массиве.
# В процессе работы алгоритм занимается сравнением и в случае необходимости
# перестановкой эл-тов в этом массиве. Новых массивов из частей исходного
# не создаётся.
# За опорный выбирается средний по расположению эл-т.
# За базовый случай принят вариант, когда в очередную итерацию передан
# массив из одного эл-та или пустой. Проверка (if right <= left) в начале
# функции это отслеживает и обеспечивает корректное "всплытие" из рекурсии.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность быстрой сортировки в худшем случае - O(N^2),
# но в среднем принимается О(Nlog N), где N - размер массива.
# Пространственная сложность - O(1) для самой функции
# и O(N) для всей программы с вводом данных.

class Pyramyd:

    def __init__(self, size):
        self.__items = [None] * size  # массив для кучи
        self.__size = size  # общий размер
        self.__lenght = 0  # текущая заполненность
        self.__point = 1  # первый свободный индекс
    
    def put(self, elem):
        """Добавить элемент в пирамиду.

        Args:
            elem (Any): добавляемый эл-т.
        Return:
            None
        По индексу .__point добавить эл-т. Затем проверить и восстановить
        свойства кучи. Алгоритм просеивания вверх.      
        """
        if self.__lenght == self.size:
            raise KeyError
        self.__items[self.__point] = elem
        self.__sift_up(self.__point)
        self.__point += 1

    def __sift_up(self, idx):
        if idx == 1:
            return
        
        parent_idx = idx // 2
        if self.__items[parent_idx] < self.__items[idx]:
            self.__items[parent_idx], self.__items[idx] = \
            self.__items[idx], self.__items[parent_idx]
            self.__sift_up(parent_idx) 


    
    def get(self):
        """Извлечь элемент с наивысшим приоритетом.add()

        Return:
            elem (Any): извлекаемый эл-т.
        Из эл-та с индексом 1 скопировать значение. Удалить эл-т.
        Перестроить кучу для сохранения свойств.
        """
        if self.__point == 1:
            return None

        result = self.__items[1]
        if self.__point == 2:  # в куче один эл-т
            self.__items[1] = None
            self.__point -= 1
            return result
        
        self.__items[1] = self.__items[self.__point - 1]

    def __get_point(self):
        return self.__point

"""
функция heapsort(array):
  # Создадим пустую бинарную кучу.
  heap = []
  
  # Вставим в неё по одному все элементы массива, сохраняя свойства кучи.
  для каждого элемента item из массива array:
    heap_add(heap, item)   # псевдокод для heap_add можно посмотреть в прошлом уроке
  
  # Будем извлекать из неё наиболее приоритетные элементы, удаляя их из кучи.
  sorted_array = []
  i = 0
  до тех пор, пока куча не пуста:
    heap, sorted_array[i] = heap_get_max_priority(heap) 
    # псевдокод для heap_get_max_priority можно посмотреть в прошлом уроке
    i += 1

"""
def main():
    count_line = int(input())
    # persons = [None] * count_line

    persons = Pyramyd(count_line)

    for i in range(count_line):
        name, points, penalty = input().split()
        # формирование массива для удобства сравнения
        persons[i] = (-int(points), int(penalty), name)

    result = get_order(persons)
    print(*result, sep='\n')


if __name__ == '__main__':
    main()

