# Задача А. Необходимо реализовать сортировку кучей.
#
# Сортируемые эл-ты состоят из трёх раличных значений. Строки и двух чисел.
# Строка означает логин, а числа - кол-во решённых задач и штраф.
# Приоритеты сортировки:
# 1. кол-во решённых задач. По убыванию, т.е. на первом месте - max.
# 2. для равных п.1 штраф вступает в сортировку. По возрастанию, min выше.
# 3. для равных п.2 логин вступает в сортировку. По алфавиту из строчных
# латинских букв.
#
# Формат ввода
# В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
# В каждой из следующих n строк задана информация про одного из участников.
# i-й участник описывается тремя параметрами:
#
# уникальным логином (строкой из маленьких латинских букв длиной до 20)
# числом решённых задач Pi
# штрафом Fi
# Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10**9.
# Формат вывода
# Для отсортированного списка участников вывести по порядку их логины
# по одному в строке.
#
# -- ПРИНЦИП РАБОТЫ --
# В Python есть встроенная операция сравнения однотипных списков,
# числа сравниваются как обычно, а строки лексикографически посимвольно.
# 1. Чтобы воспользоваться операцией сравнения необходимо на этапе ввода
# определённым образом сформировать исходный массив:
# строка на входе
# логин           баллы за задачи         баллы штрафа
#
# в массив попадает в виде
# points                          penalty                 name
# int((баллы за задачи) * -1)     int(баллы штрафа)       логин
#
# В таком виде введённые данные позволяют использовать операцию сравнения
# для оговоренной в задании логикой сортировки.
#
# 2. Сама сортировка.
# Алгоритм сортировки кучей описан в теории по адресу https://practicum.yandex.ru/learn/algorithms/courses/7f101a83-9539-4599-b6e8-8645c3f31fad/sprints/21363/topics/e7dbf42a-fd5a-434b-990d-9cfe0e3a10c8/lessons/c29642e4-76ff-47df-82d2-87848ddc7f77/
# Заключается в двух этапах:
# 1. Эл-ты подлежащего сортировке массива (потока данных) добавляются
# в бинарную кучу. После каждого добавления куча своими внутренними
# средствами перестраивается чтобы сохранить свойства.
# 2. Извлечение в результирующий массив (поток выходных данных) из кучи
# последовательно всех элементов, каждый раз с позиции самого приоритетного.
# После каждого извлечения куча также перестраивается.
# Результатом данной двухэтапной работы будет отсортированные исходные
# данные по возрастанию или убыванию, в зависимости от типа кучи.
#
# Для решения был написан класс, реализующий некоторые свойства бинарной
# кучи, достаточных для выполнения условий задачи, а именно:
# а) методы добавления, извлечения эл-та, публичные.
# б) приватные свойства и методы для инициализации и перестроения кучи.
# Конструктор принимает один аргумент - размер требуемой структуры, создаёт
# стандартный список Python размером на единицу больше, для удобства формул
# нумерации.
# Метод добавления принимает в виде единственного аргумента добавляемый эл-т.
# Вставляет его в массив эл-тов на первое незанятое место, увеличивает
# приватный счётчик длины кучи и адрес незанятой позиции. Затем запускает
# процесс перестроения кучи посредством приватного метода .__sift_up,
# реализующего алгоритм "просеивания вверх", то есть, вновь добавленный эл-т
# при необходимости перемещается по ячейкам кучи в сторону более приоритетных.
# Методу извлечения не требуются аргументы. Он запоминает значение текущего
# наиболее приоритетного эл-та(с индексом 1), затем на его место вписывает
# значение эл-та из самой старшей(последней) занятой ячейки, уменьшает
# счётчики длины кучи и адреса доступной ячейки. Затем запускает процесс
# перестроения кучи посредством приватного метода .__sift_down, реализующего
# алгоритм "просеивание вниз", то есть, эл-т нарушающий свойства кучи будет
# перемещаться в сторону менее приоритетных. Затем метод извлечения
# возвращает запомненное ранее значение как результат.
#
# 3. Вывод результата.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Решение задачи основано на принципах(свойствах) бинарной кучи.
# Методы класса, реализующие восстановление свойств кучи после добавления или
# удаления элемента, основаны на алгоритмах кучи "просеивание вверх" и
# "просеивание вниз". В их реализациях учтены варианты неверных запросов,
# а также проверяются выходы за пределы имеющегося массива, в котором
# хранится куча.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность отдельных этапов пирамидальной сортировки O(n * log n),
# где n - количество эл-ов, которые надо отсортировать. Соответственно,
# сложность временная алгоритма всей задачи в целом также O(n * log n).
# Пространственная сложность составит O(n), так как нужна память для кучи.

class Pyramyd:

    def __init__(self, size):
        self.__items = [None] * (size + 1)  # массив для кучи
        self.__size = size  # общий размер
        self.__lenght = 0  # текущая заполненность
        self.__point = 1  # первый свободный индекс
    
    def put(self, elem):
        """Добавить элемент в пирамиду.

        Args:
            elem (Any): добавляемый эл-т.
        Return:
            None
        По индексу self.__point добавить эл-т. Затем проверить и восстановить
        свойства кучи. Алгоритм просеивания вверх. Увеличить self.__point.
        """
        if self.__lenght == self.__size:
            raise KeyError
        self.__items[self.__point] = elem
        self.__sift_up(self.__point)
        self.__point += 1
        self.__lenght += 1

    def __sift_up(self, idx):
        if idx == 1:
            return
        
        parent_idx = idx // 2
        if self.__items[parent_idx] > self.__items[idx]:
            self.__items[parent_idx], self.__items[idx] = \
            self.__items[idx], self.__items[parent_idx]
            self.__sift_up(parent_idx) 

    def get(self):
        """Извлечь элемент с наивысшим приоритетом.add()

        Return:
            elem (Any): извлекаемый эл-т.
        Из эл-та с индексом 1 скопировать значение. Удалить эл-т.
        Перестроить кучу для сохранения свойств.
        """
        if self.__lenght == 0:
            return None

        result = self.__items[1]
        if self.__lenght == 1:  # в куче один эл-т
            self.__items[1] = None
            self.__point -= 1
            self.__lenght -= 1
            return result

        self.__items[1] = self.__items[self.__point - 1]
        self.__lenght -= 1
        self.__point -= 1
        self.__sift_down(1)
        return result

    def __sift_down(self, idx):
        left = 2 * idx
        right = left + 1
        
        # нет дочерних узлов
        if self.__lenght < left:
            return

        # right <= heap.size проверяет, что есть оба дочерних узла
        if (
            (right <= self.__lenght) and
            (self.__items[left] > self.__items[right])
            ):
            index_largest = right
        else:
            index_largest = left

        if self.__items[idx] > self.__items[index_largest]:
            self.__items[idx],self.__items[index_largest] = \
            self.__items[index_largest], self.__items[idx]

            self.__sift_down(index_largest) 

def main():
    count_line = int(input())

    persons = Pyramyd(count_line)

    for _ in range(count_line):
        name, points, penalty = input().split()
        # формирование эл-та для удобства сравнения
        persons.put((-int(points), int(penalty), name))

    result = [None] * count_line
    for count in range(count_line):
        result[count] = persons.get()[2]
    
    print(*result, sep='\n')


if __name__ == '__main__':
    main()

