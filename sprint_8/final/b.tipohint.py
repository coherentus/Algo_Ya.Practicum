# https://contest.yandex.ru/contest/26133/run-report/69650808/
# Задача B. Шпаргалка.
# Для заданных текста и набора строк определить, возможно ли из строк
# составить текст, стыкуя и не пересекая строки. Строки можно использовать
# не единожды или не использовать вовсе.
#
# -- ПРИНЦИП РАБОТЫ --
# Для решения задачи применена структура префиксное дерево. Используется его
# свойства хранить словарь слов и выдавать ответ, есть ли искомое слово в сло-
# варе. Поставщиком слов, вернее, последовательности символов выступает исход-
# ный текст.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# По мере получения символов бор продвигается по своим рёбрам если слово
# совпадает с подачей из текста. Если бор дошёл до конечного символа слова
# и расхождения с потоком не было, то в специально созданном массиве создаётся
# отметка о месте в тексте, с которой надо будет стартовать новую итерацию
# проверки вхождения слова. Если расхождение обнаружилось раньше, чем бор
# дошёл до конца слова, то на данном словаре соблюдая условия задачи составить
# текст нельзя.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность.
# На этапе ввода - O(N), где N - кол-во слов.
# Создание бора - O(L), где L — суммарная длина всех слов в наборе.
# Перебор слов в боре в худшем случае O(N ** 2), где N - кол-во слов.
# Итоговая - O(N) + O(L) + O(N ** 2), что даёт O(L) + O(N ** 2),
# где L — длина всех слов, а N - кол-во слов.
#
# Пространственная сложность.
# Этап ввода.
# O(Lt) + O(Lw * N), где Lt - длина текста, Lw - макс. длина слова и
# N - кол-во слов.
# Создание и заполнение бора - O(Lw * N), где Lw - макс. длина слова и
# N - кол-во слов. Несложно заметить, что  Lw * N это при худшем случае
# то же самое, что и сумма символов во всех словах, т.е. O(L).
# Тестирование комбинаций слов на совместимость с текстом.
# O(Lt), где Lt - длина текста, так как для этапа требуется массив длиной
# с текст +1.
# Итого:
# O(Lt) + O(Lw * N) +  O(Lw * N) + O(Lt), где Lt - длина текста,
# Lw - макс. длина слова и N - кол-во слов.
# Упростив для компактности - O(Lt + Lw * N), вероятно, также можно сказать,
# обобщённая пространственная сложность составит O(L), где L - общая сумма
# длин всех входных текстовых данных.

RIGHT = 'YES'
WRONG = 'NO'


class TrieNode:

    def __init__(self, char):
        self.char = char
        self.terminal = False
        self.children = {}


def make_trie(words):
    """Создать и заполненить бор.

    Args:
        words (list[str:]): набор входных слов

    Returns:
        TrieNode: голова бора

    Конец слова помечается булевым терминалом. Потомки хранятся в словаре,
    ключ - символ, значение - потомок.
    """
    root = TrieNode('')
    for word in words:
        current_node = root
        for char in word:
            if char not in current_node.children:
                new_node = TrieNode(char)
                current_node.children[char] = new_node
            current_node = current_node.children[char]
        current_node.terminal = True
    return root


def check_rized(text, words):
    """Определить, можно составить текст из набора слов.

    Args:
        text (str:): исходный текст
        words (list[str:]): набор слов

    Returns:
        const: 'YES' или 'NO' по результатам работы.

    Создаётся префиксное дерево из словаря, затем текст посимвольно
    проверяется по словам. Для ориентирования, как подходят/нет слова
    создаётся булевый массив. Механизм работы с ним: если слово закончилось
    и уложилось(совпало) с текстом, на его последнем символе в массиве ставит-
    ся отметка True. Со следующего символа начинается подача в бор новой
    последовательности. Если расхождение между текстом и тем, что может пред-
    ложить бор встречается раньше, чем кончится слово, то оно для данного
    места текста не подходит. Слова могут повторяться по условию.
    """
    # создание и заполнение бора
    root = make_trie(words)

    # массив признаков достижимости dp
    is_posbl = [False] * (len(text) + 1)
    is_posbl[0] = True

    for dp_idx in range(len(text)):
        node = root

        if is_posbl[dp_idx]:
            for str_idx in range(dp_idx, len(text) + 1):

                if node.terminal:
                    # данная точка(комбинация) достижима на словаре
                    is_posbl[str_idx] = True

                # текст кончился или следующей буквы из текста нет в текущем
                # слове в текущем месте
                if str_idx == len(text):
                    break
                char_in_bor = node.children.get(text[str_idx], False)
                if not char_in_bor:
                    break

                node = char_in_bor

    if is_posbl[-1]:
        return RIGHT
    return WRONG


def main():
    """Ввести данные, вызвать обработку, напечатать результат."""
    # ввод данных
    with open('input.txt') as file_in:
        # В первой строке дан текст T, который надо разбить на слова.
        # Длина T не превосходит 10^5. Текст состоит из строчных букв
        # английского алфавита.
        # Во второй строке записано число допустимых к использованию
        # слов 1 ≤ n ≤ 100.
        # В последующих n строках даны сами слова, состоящие из маленьких
        # латинских букв. Длина каждого слова не превосходит 100.

        text = file_in.readline().strip()
        num_words = int(file_in.readline())
        words = [None] * num_words
        for idx in range(num_words):
            words[idx] = file_in.readline().strip()

        print(check_rized(text, words))


if __name__ == '__main__':
    main()
