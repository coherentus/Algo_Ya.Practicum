# https://contest.yandex.ru/contest/26133/run-report/69651305/
# Задача A. Packed Prefix.
# Для определения наибольшего общего префикса заданных 'запакованных' строк
# необходимо сначала вернуть им распакованную форму.
#
# -- ПРИНЦИП РАБОТЫ --
# По сути, необходимо, начиная с элементарных, то есть содержащих внутри
# только символы, пар из открывающей и закрывающей скобки, заменять строку
# внутри на повторенную согласно множителю. Множитель также удаляется.
# Для подобного рода преобразований удобно использовать структуру типа стека,
# но с возможностью оценить содержимое вершины без извлечения. Стандартный
# тип Python-а 'list' вполне подошёл.
# Работа алгоритма в общем виде представляет следующее:
# Входная строка перебирается по индексу слева(с нулевого индекса).
# Перебор реагирует на открывающую и закрывающую скобки.
# При открывающей скобке в стек добавляется предшествующая скобке(точнее
# множителю) строка, если таковая есть, затем в стек добавляется множитель.
# При закрывающей скобке проверяется её элементарность и наличие предыдущих
# строк в стеке.
# Для отслеживания символов введены два указателя: 'start_char' и 'stop_idx'.
# Первый содержит индекс первого эл-та, а второй - индекс эл-та, следующим за
# последним эл-том потенциальной строки. В моменты инициализации и обновлений
# данные указатели получают значения возможных начала и окончания подстрок.
# Решение о действительности существования строки принимается в процессе
# обработки скобок и зависит, в том числе, от соотношений между индексами.
# По мере продвижения по исходной строке и раскрытия скобок в стеке
# накапливаются подстроки, которые затем конкатенируются перед возвратом.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# По условию входные строки корректны, т.е. каждая открывающая скобка снабжена
# множителем, закрыта без нарушений скобочной последовательности и между
# скобками содержится хотя бы один символ. Поэтому проверки всех этих ситуаций
# не проводятся.
# Символы в начале строки до первой скобки корректно отслеживаются и заносятся
# в стек.
# После отработки основного цикла в стек также добавляется остаток символов.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность.
# Этап ввода - O(L * N), где L - длина наибольшей вводимой строки, а N - их
# количество.
# Распаковка строк.
# Кол-во операций в алгоритме зависит от длины входных строк. От неё же зави-
# сит вложенность скобок, также линейно. Следовательно, сложность обработки
# одной строки составляет O(L), а всего этапа распаковки - O(N * L), где
# N - кол-во строк, а L - длина наибольшей строки.
# Нахождение префикса.
# Сложность составит O(L * N), где L - длина наименьшей строки,
# а N - кол-во строк.
# Итого: 2 * O(L * N) в худшем случае, где L - длина наибольшей строки,
# а N - кол-во строк. Или просто O(L * N). Или даже O(L), где L - суммарная
# длина всех входных данных.
#
# Пространственная сложность.
# Этап ввода.
# O(N * L), где N - кол-во строк, а L - длина наибольшей строки.
# Этап распаковки O(N * L) + O(L), что даёт O(N * L), где N - кол-во строк,
# а L - длина наибольшей строки.
# Этап поиска префикса 2 * O(L), где L - длина, в худшем случае, самой длинной
# строки.
# Итого: 2 * O(N * L) + 2 * O(L), что даёт O(N * L), где N - кол-во строк,
# а L - длина наибольшей строки.

from typing import Any, List, Tuple

LSB = '['  # Left Square Bracket
RSB = ']'  # Right Square Bracket
STR = 's'  # string
MUL = 'm'  # multiplier


def unpack_str(pack_string: str):
    # start_char - индекс первого эл-та возможной строки
    # stop_idx - индекс эл-та ПЕРЕД которым оканчивается
    # возможная строка
    start_char = 0

    # стек для работы алгоритма, записываются кортежи вида (тип, значение)
    # типы - 's' строка, 'm' множитель
    # в некоторых случаях проверяется тип хранимого на вершине через [-1][0]
    stack: List[Tuple[str, Any]] = []
    tmp_string = ''
    for idx in range(len(pack_string)):
        char = pack_string[idx]
        # левая скобка
        if char == LSB:
            # обработка предшествующей строки
            # если есть, добавляется в стек
            stop_idx = idx - 1
            stack.append((STR, pack_string[start_char:stop_idx]))

            # обработка множителя
            stack.append((MUL, int(pack_string[idx - 1])))

            # завершение работы с открывающей скобкой, анонс следующей строки
            start_char = idx + 1

        # правая скобка
        elif char == RSB:
            # два варианта соотношения start_char и stop_idx
            stop_idx = idx
            if stop_idx > start_char:
                # перед скобкой есть символ(-ы)
                # скобка может быть самой вложенной, тогда на вершине стека
                # лежит множитель. Достаём, множим срез на множитель и кладём
                # в стек строкой.
                # Если лежит строка, то это или рез-т предыдущего раскрытия
                # скобок или часть исходной строки. Достаём, конкатенируем
                # срез справа и кладём в стек строкой.
                tmp_string = pack_string[start_char:stop_idx]
                type_item, item = stack.pop()
                if type_item == MUL:
                    # item: int
                    stack.append((STR, tmp_string * item))
                else:
                    # item: str
                    stack.append((STR, item + tmp_string))

            # закрывающие скобки подряд
            elif stop_idx == start_char:
                _, tmp_string = stack.pop()

                # в стеке могут лежать несколько строк от предыдущего
                # раскрытия скобок
                while stack[-1][0] == STR:
                    _, tmp_string_prev = stack.pop()
                    tmp_string = tmp_string_prev + tmp_string
                _, mul = stack.pop()
                stack.append((STR, tmp_string * mul))

            # завершение работы с закрывающей скобкой, анонс следующей строки
            start_char = idx + 1

    # есть символы без множителя в конце строки
    if start_char < idx + 1:
        stack.append((STR, pack_string[start_char:idx + 1]))

    if stack:
        return ''.join([string for _, string in stack])

    # стека нет, значит во входной строке не было множителей, вернуть как есть
    return pack_string


def get_prefix(strings):
    """Найти максимальный префикс из распакованных строк.

    Args:
        strings (str:): Строки в запакованном виде

    Returns:
        str: Строка максимального общего префикса распакованных строк.
    Не меняет входные данные.

    Строки отправляются на распаковку по одной. Первая строка берётся
    за образец, остальные посимвольно с нулевого индекса сравниваются с ней.
    Место расхождения фиксирует новый минимум (или нет) и инициирует
    завершение обработки текущей строки.
    По окончании распакованных строк возвращается срез эталонной строки
    представляющий максимальный общий префикс всех строк.
    """
    max_prefix = 100001
    examing_string = ''
    etalon_str = unpack_str(strings[0])
    for idx_str in range(1, len(strings)):
        examing_string = unpack_str(strings[idx_str])
        cur_len_str = min(len(etalon_str), len(examing_string))
        for idx_char in range(cur_len_str):
            if etalon_str[idx_char] != examing_string[idx_char]:
                max_prefix = min(max_prefix, idx_char)
                break

    return etalon_str[0:max_prefix]


def main():
    """Ввести данные, вызвать обработку, напечатать результат."""
    # ввод данных
    with open('input.txt') as file_in:
        # В первой строке записано число n (1 ≤ n ≤ 1000) –— число строк.
        # Далее в n строках записаны запакованные строки.
        num_string = int(file_in.readline())
        strings = [None] * num_string
        for i in range(num_string):
            strings[i] = file_in.readline().strip()

        print(get_prefix(strings))


if __name__ == '__main__':
    main()
