# https://contest.yandex.ru/contest/22450/run-report/64566118/
# Задача: дан массив произвольных положительных целых чисел и нулей.
# Один ноль обязательно есть.
# Необходимо для каждого числа определить расстояние до ближайшего нуля.
#
# Вариант решения за один проход:
# Перебирать последовательно все эл-ты. В промежутках между нулями по
# порядку вписывать возрастающие значения начиная с единицы. При встрече
# очередного нуля - значения первой половины промежутка развернуть и вписать
# на место второй половины.
#
# Работа алгоритма.
# 1. Создать выходной массив из нулей длиной == входному.
# 2. Создать итератор enumerate() из входного массива.
# Нужен для доступа к индексу эл-та.
# 3. Создать счётчик шагов. У него две функции - собственно счётчик,
# а также признак того, в промежутке ли между нулями текущая позиция.
# 4. Создать переменную для хранения индекса левого нуля.
# Используется для разворота "половины" значений из промежутка между нулями
# или всего промежутка от начала массива до первого нуля.
#
# Сама итерация по входному массиву:
# два варианта, очередной эл-т нуль или число.
# Если не ноль, то увеличить кол-во шагов и это значение вписать в выходной
# массив по индексу текущего эл-та.
#
# Если ноль, то два варианта, были шаги или нет.
# Если шагов не было, значит предыдущий эл-т тоже ноль. Обновить left_zero.
#
# Если шаги были, то два варианта: левее ноль был уже или ещё не было.
# Если не было, то все значения (1, 2, 3, ...), вписанные в вых. массив до
# текущего эл-та, достать, развернуть и вписать обратно (..., 3, 2, 1)
#
# Если левее ноль уже был, значит закрылся промежуток. Достать из выходного
# массива левую часть значений текущего промежутка вида (1, 2, 3, ...)
# ровно половину, при чётном кол-ве эл-тов, или половина минус один.
# Развернуть и вписать вместо второй, правой части промежутка:
# (1, 2, 3, ..., N-2, N-1, N) -> (1, 2, 3, ..., 3, 2, 1)
#
# После обработки варианта с шагами обнулить счётчик шагов.
#
# После обработки нулевого входного эл-та обновить left_zero
# (присвоить индекс текущего эл-та), в выходной массив ничего не писать,
# там нули уже есть.
#
# Продолжать пока не кончится входной массив.
# Вернуть выходной массив.

from typing import List, Optional


def closest_zero(houses: List[str], lenght: int) -> List[int]:
    """Для эл-тов списка найти расстояние до ближайшего 0.

    На входе -
    houses: список строк. Одна из них обязательно == '0'.
    lenght: длина списка.
    На выходе - список целых значений, где 0 позиционно
    соответствует '0' из houses, а остальные == расстоянию
    до ближайшего '0'.
    """
    left_zero: Optional[int] = None
    answer: List[int] = [0] * lenght
    work_houses: enumerate = enumerate(houses)
    steps: int = 0
    for index, value in work_houses:
        if value != '0':  # во входном массиве попался номер дома
            steps += 1
            # пишем нарастающие значения от 1
            answer[index] = steps
        else:  # во входном массиве попался ноль
            if steps:  # если есть шаги - есть промежуток значений
                if left_zero is not None:  # левый ноль уже есть
                    # между индексами left_zero и index
                    # в answer вписаны значения вида "1, 2, 3, ..., N"
                    # длина или (index - left_zero) или steps

                    # halfed - счётчик нужных эл-тов
                    # если steps чётный, то берёт половину
                    # если steps нечётный, то берёт до середины невключительно
                    halfed: int = steps // 2
                    left_start = left_zero + 1

                    answer[index - halfed: index] = (
                        answer[left_start: left_start + halfed][::-1]
                    )
                else:
                    # левый ноль не определён, диапазон от начала до '0'
                    # заполнен '1, 2, 3, ..., N'. разворачиваем
                    answer[0: index] = answer[0: index][::-1]
                steps = 0
            # шагов нет, значит повторяется 0
            # обновляем левый ноль
            left_zero = index
    return answer


def main():
    num_count: int = int(input())
    input_numbers: List[str] = [x for x in input().split()]
    results: List[int] = closest_zero(input_numbers, num_count)
    print(*results)


if __name__ == '__main__':
    main()
