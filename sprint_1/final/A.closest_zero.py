# https://contest.yandex.ru/contest/22450/run-report/64599230/
# Задача: дан массив произвольных положительных целых чисел и нулей.
# Один ноль обязательно есть.
# Необходимо для каждого числа определить расстояние до ближайшего нуля.
#
# Вариант решения за один проход:
# Перебирать последовательно все эл-ты. В промежутках между нулями по
# порядку вписывать возрастающие значения начиная с единицы. При встрече
# очередного нуля - значения первой половины промежутка развернуть и вписать
# на место второй половины.
#
# Работа алгоритма.
# 1. Создать выходной массив из нулей длиной == входному.
# 2. Создать итератор enumerate() из входного массива.
# Нужен для доступа к индексу эл-та.
# 3. Создать переменную для хранения индекса левого нуля.
# Используется для отслеживания одного из двух вариантов местоположения
# текущего эл-та, в полуинтервале от начала массива до первого нуля или
# в промежутке между нулями.
#
# Сама итерация по входному массиву:
# два варианта, очередной эл-т нуль или число.
# Если не ноль, то проверить левый ноль, если есть, то в выходной массив
# вписать (index - left_zero).
#
# Если ноль, то два варианта, был уже левый ноль или нет.
# Если был, возможен промежуток, сравнить предыдущий индекс с left_zero,
# если ноль повторяется - обновить left_zero и к след. итерации.
#
# Если левый ноль и тек. индекс различаются больше, чем на 1,
# то имеем промежуток с вписанными значениями вида (1, 2, ..., N-1, N).
# Во вторую "половину" вписать значения через range(XX, 0, -1).
#
# Если левого ноля не было, вписать значения через range(index, 0, -1).
#
# Обновить левый ноль.

from typing import List, Optional


def closest_zero(houses: List[str]) -> List[int]:
    """Для эл-тов списка найти расстояние до ближайшего 0.

    На входе -
    houses: список строк. Одна из них обязательно == '0'.
    lenght: длина списка.
    На выходе - список целых значений, где 0 позиционно
    соответствует '0' из houses, а остальные == расстоянию
    до ближайшего '0'.
    """
    left_zero: Optional[int] = None
    answer: List[int] = [0] * len(houses)
    work_houses: enumerate = enumerate(houses)

    for index, value in work_houses:
        if value != '0':  # во входном массиве попался номер дома
            if left_zero is not None:
                # пишем нарастающие значения от 1
                answer[index] = index - left_zero

        else:  # во входном массиве попался ноль
            if left_zero is not None:  # левый ноль уже есть
                # ноль повторяется без промежутка
                if index - left_zero == 1:
                    # обновляем левый ноль
                    left_zero = index
                    continue

                # между индексами left_zero и index
                # в answer вписаны значения вида "1, 2, 3, ..., N"
                # длина (index - left_zero)

                # halfed - счётчик нужных эл-тов
                # если длина чётная, то берёт половину
                # если нечётная, то берёт до середины невключительно
                halfed: int = (index - left_zero) // 2
                # в правую "половину" пишем от максимума до 1
                answer[index - halfed: index] = range(halfed, 0, -1)
            else:
                # левый ноль не определён, диапазон от начала до '0'
                # заполнен '1, 2, 3, ..., N'. заполняем значениями
                # от максимального до 1
                answer[0: index] = range(index, 0, -1)

            # обновляем левый ноль
            left_zero = index
    return answer


def main():
    _: int = int(input())
    input_numbers: List[str] = [x for x in input().split()]
    results: List[int] = closest_zero(input_numbers)
    print(*results)


if __name__ == '__main__':
    main()
