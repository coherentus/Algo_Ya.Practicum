
Задача А. Дек.
Реализовать структуру данных Дек со следующими свойствами:
- Размер в эл-тах задаётся при создании, в процессе использования
изменение размера не предустмотрено.
- Эл-ты можно добавлять и забирать как с начала, так и с конца
по одному за операцию.
- Операции добавления и извлечения должны иметь сложность О(1)
- При реализации нельзя использовать связный список.

-- ПРИНЦИП РАБОТЫ --
Если за ключевое условие задания взять пространственную сложность,
то значит для оперций добавления/извлечения недопустимы переборы
эл-тов проектируемой структуры полные и даже частичные, ибо вносят
зависимость временной сложности от кол-ва эл-тов.

Далее, на каждый момент времени достаточно знать всего два эл-та:
головной и хвостовой, а также текущую заполненность дека.

Если каждую из четырёх операций по добавлению/извлечению эл-тов
удастся реализовать в несколько действий, независящих ни от эл-та,
ни от их количества, ни от размера дека, то временная сложность
их работы составит необходимую О(1).

В языке Python есть удобная встроенная структура данных - список.
Возможна инициализация сразу с нужным размером. Есть доступ к эл-там
по индексам за О(1). Для реализации дека остаётся добавить несколько
вспомогательных переменных.
Всё месте удобно реализовать в виде класса.

Конструктор класса принимает аргумент - требуемый размер дека.
В соответствии с этим параметром создаётся приватный атрибут класса
типа список - хранилище эл-тов дека.
Далее создаются приватные атрибуты - указатели головы и хвоста дека.
В них хранятся индексы головного и хвостового эл-та соответственно.
Ещё один приватный атрибут - счётчик эл-тов, находящихся в деке.

Счётчик служит для отслеживания попыток извлечения из пустого или
записи в заполненный дек. Если операция логически невозможна,
то генерируется кастомное исключение, которое отслеживает внешняя
функция обработки очереди команд.

Атрибуты __tail, __head  и __lenght инициализируются нулями.

Общая схема работы методов добавления/извлечения эл-тов:
# 1. Проверить возможность операции. Если невозможна - выбросить исключение.
2. Определить индекс куда/откуда писать/забирать эл-т, вписать/считать,
обновить индекс.
3. Обновить счётчик наполненности дека.

Смысл значений индекса головы и хвоста немного различаются:
индекс головы __head указывает на текущую голову (куда писать новую
нужно вычислять, а текущее значение можно взять по этому индексу)
индекс хвоста __tail указывает на следующуую ячейку после текущего хвоста
(индекс текущего хвоста нужно вычислять, а писать новый хвост можно
сразу по этому индексу)




-- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
В моей реализации для добавления эл-та используется 4 операции,
для извлечения - 5. Все они имеют как пространственную,
так и временную сложность О(1).
Поэтому и суммарные пространственная и временная сложности работы
методов добавления и звлечения элементов будут - О(1).

from typing import Callable, List, Optional


class OverLenght(Exception):
    """Исключение для ошибок переполнения."""

    def __init__(self, message):
        self.message = message


class ZeroLenght(Exception):
    """Исключение для ошибок извлечения из пустого дека."""

    def __init__(self, message):
        self.message = message


class Deque():
    """Дек - двусторонняя очередь.

    Построен на типе List.
    Конструктор принимает аргумент size - размер дека.
    Имеет методы для добавления и извлечения эл-тов,
    как с головы, так и хвоста.
    Для манипуляций используются индексы эл-тов.
    Изменение размера не предусмотрено.
    В случае ошибок длины дека генерит исключения:
    OverLenght
    ZeroLenght
    """

    def __init__(self, size: int) -> None:
        """Создать экземпляр класса Дек.

        Аргумент:
            size (int): размер структуры в элементах.
        Атрибуты:
        __size - максимальный размер
        __lenght - текущая длина
        __head - индекс для операций с головой дека.
        новую голову писать по индексу (__head - 1),
        текущую читать по индексу __head.
        __tail - индекс для операций с хвостом дека.
        новый писать по индексу __tail,
        текущий хвост читать по индексу (__tail + 1)
        __items - эл-ты дека
        """
        self.__size: int = size
        self.__items: List[Optional[str]] = [None] * size
        self.__lenght: int = 0
        self.__head: int = 0
        self.__tail: int = 0

    def __check_max_lenght(self) -> None:
        """Выбросить ошибку если для заполненного дека вызван push()."""
        if self.__lenght == self.__size:
            raise OverLenght(f'Текущий размер дека = {self.__lenght}'
                             ' Добавление элемента невозможно')

    def __check_zero_lenght(self) -> None:
        """Выбросить ошибку если при нулевой длине вызван pop()."""
        if self.__lenght == 0:
            raise ZeroLenght(f'Текущий размер дека = {self.__lenght}'
                             ' Извлечение элемента невозможно')

    def __calc_idx(self, idx: int, value: int) -> int:
        """Вспомогательный метод для пересчёта индекса.

        Аргументы:
            idx - исходный индекс
            value - требуемое смещение со знаком
        Метод возвращает корректное значение для индекса кольцевой структуры
        используя деление по модулю из максимального размера self.__size
        """
        return (idx + value) % self.__size

    def push_back(self, item: str) -> None:
        """Добавить эл-т после хвоста дека.

        Если текущая длина меньше размера:
        По индексу __tail вписать новый эл-т.
        "Увеличить" __tail.
        Увеличить __lenght.
        """
        self.__check_max_lenght()
        self.__items[self.__tail] = item
        self.__tail = self.__calc_idx(self.__tail, +1)
        self.__lenght += 1

    def push_front(self, item: str) -> None:
        """Добавить эл-т перед головой дека.

        Если текущая длина меньше размера:
        "уменьшить" __head, вписать новый эл-т.
        Увеличить __lenght.
        """
        self.__check_max_lenght()
        self.__head = self.__calc_idx(self.__head, -1)
        self.__items[self.__head] = item
        self.__lenght += 1

    def pop_back(self) -> Optional[str]:
        """Снять эл-т с хвоста дека.

        Если текущая длина не ноль:
        "Уменьшить" __tail.
        Взять эл-т по индексу __tail, вписать None.
        Уменьшить длину дека __lenght.
        Вернуть эл-т.
        """
        self.__check_zero_lenght()
        self.__tail = self.__calc_idx(self.__tail, -1)
        res: Optional[str] = self.__items[self.__tail]
        self.__items[self.__tail] = None
        self.__lenght -= 1
        return res

    def pop_front(self) -> Optional[str]:
        """Снять эл-т с головы дека.

        Если текущая длина не ноль:
        Взять эл-т по индексу __head, вписать None.
        "Увеличить" __head.
        Уменьшить длину дека __lenght.
        Вернуть эл-т.
        """
        self.__check_zero_lenght()
        res: Optional[str] = self.__items[self.__head]
        self.__items[self.__head] = None
        self.__head = self.__calc_idx(self.__head, +1)
        self.__lenght -= 1
        return res


def parse_run_command(deque: Deque, command_full: str) -> Optional[str]:
    command, *args = command_full.split()
    method: Callable = getattr(deque, command)
    try:
        result: Optional[str] = method(*args)
    except (ZeroLenght, OverLenght):
        result = 'error'
    return result


def main():
    commands_count: int = int(input())
    deque_size: int = int(input())
    loc_deque = Deque(deque_size)
    for _ in range(commands_count):
        input_command: str = input()
        res_command: Optional[str] = (
            parse_run_command(loc_deque, input_command)
        )
        if res_command is not None:
            print(res_command)
    """with open('input.txt', 'r') as f_in, open('output.txt', 'w') as f_out:
        commands_count: int = int(f_in.readline())
        deque_size: int = int(f_in.readline())
        loc_deque = Deque(deque_size)
        for _ in range(commands_count):
            input_command: str = f_in.readline()
            res_command: Optional[str] = (
                parse_run_command(loc_deque, input_command)
            )
            if res_command is not None:
                f_out.write(res_command + '\n')"""


if __name__ == '__main__':
    main()
