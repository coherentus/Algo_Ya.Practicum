# https://contest.yandex.ru/contest/22781/run-report/65137841/
# Задача B. Калькулятор.
# В единственной строке дано выражение в обратной польской нотации.
# Числа и арифметические операции записаны через пробел.
# На вход могут подаваться операции: +, -, *, / и числа,
# по модулю не превосходящие 10000.
# Гарантируется, что значение промежуточных выражений
# в тестовых данных по модулю не больше 50000.
#
# Замечание про отрицательные числа и деление:
# в этой задаче под делением понимается математическое целочисленное деление.
# Это значит, что округление всегда происходит вниз.
# А именно: если a / b = c, то b ⋅ c — это наибольшее число,
# которое не превосходит a и одновременно делится без остатка на b.
# Например, -1 / 3 = -1.
#
# Для решения использовать стек.
# На выходе ожидается единственное число — значение выражения.
#
# -- ПРИНЦИП РАБОТЫ --
# В самом задании дано исчерпывающее описание алгоритма.
# https://contest.yandex.ru/contest/22781/problems/B/
# Решение сводится к корректному воплощению этого описания.
#
# В Python есть структура данных "список", имеющая простые в использовании
# методы добавления и извлечения эл-та .push()  и .pop(). На них,
# на списке и его методах, и построена работа алгоритма.
#
# Входной поток разбивается на подстроки, если в подстроке опознан знак
# операции, то соответсвующая операция выполняется над извлечёнными двумя
# последними операндами, если не операция - то подстрока считается числом и
# как операнд заносится в стек.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# В условии оговорено, что на входе только числа и знаки операций,
# то есть достаточно определить, попался знак операции или нет, проверять
# корректность чисел нет необходимости.
# Тем не менее введена проверка на возможность извлечения операнда из стека.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Методы списка Python .push() и .pop() в имеют временную и пространственную
# сложности О(1), все остальные манипуляции также не зависят от количества
# входных данных, кроме операции ввода. Она имеет как временную так
# пространственную сложность О(n).
# Следовательно, весь алгоритм имеет сложности О(n).

from typing import Callable, Dict, List

OPERATIONS: Dict[str, Callable[[int, int], int]] = {
    '+': lambda x, y: x + y,
    '-': lambda x, y: x - y,
    '*': lambda x, y: x * y,
    '/': lambda x, y: x // y,
}


class Stack():

    def __init__(self) -> None:
        self.__items: List[int] = list()

    def push(self, item: int) -> None:
        self.__items.append(item)

    def pop(self) -> int:
        try:
            pop_res: int = self.__items.pop()
        except IndexError:
            print('Ошибка. Стек пуст. Извлечь значение невозможно.')
            raise
        return pop_res


def calc_reverse_polish_notation(expression: str) -> int:
    """Вычислить значение выражения в обратной польской нотации.

    На входе:
    - expression: строка из целых чисел и знаков операций +, -, *, /
    числа по модулю не превосходят 10000. Операнды разделены пробелами.
    Возврат:
    Если удалось рассчитать выражение:
    - int: Результат вычисления. Деление применяется целочисленное.
    В противном случае:
    - str: Текст сообщеня об ошибке.

    Входную строку разбить на подстроки.
    Пока есть подстроки, если подстрока не является знаком
    операци из (+ - * /), считать подстроку числом и заносить в стек,
    приведя к int-у. Если встречена операция, извлечь из стека значение для
    второго операнда, затем извлечь значение для первого операнда,
    произвести между ними найденное действие,
    полученное значение положить на вершину стека.
    По окончании подстрок снять с вершины стека значение, вернуть его
    в качестве результата.
    """
    operand_stack = Stack()
    sequence: List[str] = expression.split()
    for item in sequence:
        if item not in OPERATIONS:
            operand_stack.push(int(item))
        else:
            second: int = operand_stack.pop()
            first: int = operand_stack.pop()
            operation: Callable[[int, int], int] = OPERATIONS[item]
            result: int = operation(first, second)
            operand_stack.push(result)
    return operand_stack.pop()


if __name__ == '__main__':
    input_line: str = input()
    print(calc_reverse_polish_notation(input_line))
