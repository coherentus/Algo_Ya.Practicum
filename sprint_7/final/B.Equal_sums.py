# https://contest.yandex.ru/contest/25597/run-report/69628963/
# Задача B. Одинаковые суммы.
# Определить, возможно ли разбиение данной последовательности неотрицательных
# целых чисел на две части так, чтобы суммы чисел в частях совпадали.
#
#
# -- ПРИНЦИП РАБОТЫ --
# Для начала считается сумма всей последовательности.
# Затем отбрасываются очевидно невозможные варианты, а именно:
# - нечётная сумма всей последовательности.
# - последовательность с нечётным количеством нечётных чисел.
# - последовательность, в которой есть эл-т, больший половины суммы.
# В остальных вариантах существует вероятность разбиения.
# Для её поиска вычисляется полусумма(половина суммы всей последовательности
# или сумма одной из частей разбиения), берётся максимальный эл-т после-
# довательности(последовательность уже была отсортирована по убыванию на
# подготовительном этапе). Этот элемент становится элементом одной из
# подпоследовательностей разбиения, а разность из полусуммы и этим эл-том
# становится тем числом, возможность составления из оставшихся и предстоит
# найти.
# Для поиска используется перебор всех вариантов сумм чисел из последователь-
# ности следующим образом:
# - создаётся массив dp размерностью (искомое_число + 1) из False, нулевому
# эл-ту присваивается True. Смысл(назначение) эл-тов этого массива в том,
# чтобы означать достижимость суммы, численно равной индексу эл-та, при
# переборе эл-тов последовательности.
# Например, дана последовательность [1, 2, 3, 4] и число(сумма) 7
# idx_dp      0  1  2  3  4  5  6  7
# dp[idx_dp]  T  F  F  F  F  F  F  F   после инициализации
# теперь в цикле перебираем эл-ты. Берём очередной эл-т из набора и начиная
# с конца dp(от dp[-1] до dp[знач_эл-та] с шагом 1) смотрим, что находится
# в dp[idx_dp - знач_эл-та], если там True, значит сумма,
# равная idx_dp - знач_эл-та достижима каким-то сочетанием предыдущих эл-тов.
# Тогда для для текущего индекса dp_idx необходимо эл-т dp[dp_idx] отметить
# True. Таким образом текущий эл-т вложит свой вклад в возможные варианты
# сумм, которые можно получить из данного набора чисел.
# dp[idx_dp]  T  T  F  F  F  F  F  F   после проведения '1'
# dp[idx_dp]  T  T  T  T  F  F  F  F   после проведения '2'
# dp[idx_dp]  T  T  T  T  T  T  T  F   после проведения '3'
# dp[idx_dp]  T  T  T  T  T  T  T  T   после проведения '4'
# Как видно, после проведения через dp четвёрки, в dp[-1] появилось True,
# это значит, что среди чисел [1, 2, 3, 4] есть такие, что дают в сумме 7.
# Если перебирать числа по убыванию, то True в dp[-1] появилось бы уже на
# втором шаге:
# idx_dp      0  1  2  3  4  5  6  7
# dp[idx_dp]  T  F  F  F  F  F  F  F   после инициализации
# dp[idx_dp]  T  F  F  F  T  F  F  F   после проведения '4'
# dp[idx_dp]  T  F  F  T  F  F  F  T   после проведения '3'
# Общая цель алгоритма - получить True
# в dp[-1] рано или поздно. Если после перебора всех эл-тов этого не слу-
# чилось, то исходная последовательность не разделяется на равные суммы.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Нечётность суммы последовательности, как признак неразбиваемости.
# В задаче речь идёт о равенстве двух сумм. Если одну из сумм обозначить
# как N, то общую сумму можно выразить через 2 * N. А умножением целого числа
# на 2 невозможно получить нечётное число, значит последовательность
# с нечётной общей суммой не разбивается.
# Нечётное количество нечётных членов, как признак неразбиваемости.
# Если в исходной последовательности будет нечётное кол-во нечётных чисел, то
# при разбиении в одну часть попадут чётное кол-во или ноль нечётных чисел, а
# в другую - чётное кол-во. При этом чётности частей не совпадут,
# а следовательно и суммы не могут получиться равными.
# Превышение максимального эл-та полусуммы.
# Если в последовательности есть эл-т, превышающий половину суммы, то сумма
# оставшихся эл-тов будет меньше полусуммы, то есть, разбиение невозможно.
#
#
# -- ОЦЕНКА СЛОЖНОСТИ --
#
# Временная сложность.
# Вычисление суммы - O(N), где N - кол-во эл-тов входной последовательности.
# Сортировка последовательности - O(logN), где N - кол-во эл-тов
# последовательности.
# Подсчёт нечётных эл-тов - O(N), где N - кол-во эл-тов последовательности.
# Основной алгоритм - O(N * K/2), где N - кол-во эл-тов последовательности,
# K - сумма всех эл-тов входной последовательности.
# Итого:
# 2 * O(N) + O(logN) + O(N * K/2), после упрощения - O(logN) + O(N * K),
# где N - кол-во эл-тов во входной последовательности, K - их сумма.

def get_parity(score_arr):
    # Если сумма нечётна - ответ False
    scores_sum = sum(score_arr)
    if scores_sum % 2:
        return False

    # Полусумма
    scores_sum_half = scores_sum // 2

    score_arr = sorted(score_arr, reverse=True)

    # есть ли эл-т больше полусуммы
    max_score = score_arr[0]
    if scores_sum_half < max_score:
        return False

    # кол-во нечётных эл-тов должно быть чётным
    odd_count = 0
    for item in score_arr:
        if item % 2:
            odd_count += 1
    if odd_count % 2:
        return False

    # первое слагаемое - max_score
    if max_score == scores_sum_half:
        return True
    final_sum = scores_sum_half - max_score

    # массив накопления признаков сумм
    dp = [False] * (final_sum + 1)
    dp[0] = True

    # перебирая эл-ты от scores[1] до scores[-1] в массиве dp будут
    # ставится 'True' на местах всех возможных сумм из просматриваемых
    # эл-тов.
    # если в процессе в dp[-1] появится 'True' - разбиение возможно.
    for idx_elem in range(1, len(score_arr)):
        cur_elem = score_arr[idx_elem]
        # очередной эл-т больше нужного
        if cur_elem > final_sum:
            continue
        # бинго, фин_сумма найдена из одного эл-та
        elif cur_elem == final_sum:
            return True

        # остальные эл-ты меньше фин_суммы и могут её составить
        for idx_dp in range(final_sum, cur_elem - 1, -1):
            if dp[idx_dp - cur_elem]:
                dp[idx_dp] = True
        if dp[final_sum]:
            return True

    return False


def main():
    with open('input.txt') as file_in:
        # кол-во матчей
        num_duels = int(file_in.readline())
        if num_duels:
            # очки за матчи
            scores = list(map(int, file_in.readline().split()))
            file_in.close()
            print(get_parity(scores))
        else:
            print('False')


if __name__ == '__main__':
    main()
