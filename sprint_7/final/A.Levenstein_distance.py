# https://contest.yandex.ru/contest/25597/run-report/69639392/
# Задача A. Расстояние по Левенштейну.
# Для данных двух строк определить расстояние Левенштейна.
#
#
# -- ПРИНЦИП РАБОТЫ --
# Теория, доказательство и пример алгоритма подробно описаны по адресу:
# https://ru.wikipedia.org/wiki/Расстояние_Левенштейна
# Суть работы алгоритма Вагнера — Фишера, которым решена задача, состоит
# в заполнении матрицы M x N, где M и N - длины сравниваемых строк.
# Заполнение идёт построчно. На каждом шаге вычисляются стоимости действий,
# замены, вставки или удаления символа в первой строке для его совпадения с
# символом во второй. Значением ячейки принимается меньшая стоимость операции.
# При этом учитываются уже вычисленные значения из предыдущей строки матрицы.
# Ответом является значение из последней ячейки матрицы.
# Для сокращения расхода памяти можно не хранить всю матрицу целиком. Для
# запонения очередной строки достачно иметь предыдущую.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# По условиям задачи при вычислении расстояния учитываются три операции,
# добавления, удаления и замены символа. Стоимость всех операций идентична
# и равна 1.
# Необходимая для работы алгоритма 'каёмка' верно инициализируется.
# Построение матрицы идёт построчно, на каждом шаге обработки строки из
# предыдущих результатов требуется лишь предыдущая строка, что обеспечивается
# её сохранением в начале итерации по новой строке.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
#
# Временная сложность.
# Предварительная подготовка, то есть переопределение номеров строк и их длин
# имеет сложность O(1).
# Сам алгоритм имеет сложность O(M * N + N), где M и N - длины строк.
# Итоговая сложность - O(M * N), где M и N - длины строк.
# Пространственная сложность в варианте использования двух строк
# составит O(2 * M), где M - длина короткой строки.

def get_levenshtein(string_one, string_two):
    # между идентичными строками расстояние равно нулю
    if string_one == string_two:
        return 0

    # если одна строка пуста, то расстояние равно длине другой строки
    if not (string_one and string_two):
        return max(len(string_one), len(string_two))

    # для удобства работы алгоритма первой строкой берётся более короткая
    cols, rows = len(string_one), len(string_two)
    if rows < cols:
        cols, rows = rows, cols
        string_one, string_two = string_two, string_one

    # 'каёмка' из стартовых строки и столбца матрицы предствляют наборы
    # от 0 до длины входной строки, для строки - короткой входной,
    # для столбца - длинной. Строка инициализируется сразу целиком,
    # первое значение столбца - на каждой итерации по строкам.
    cur_row = range(cols + 1)
    btm_row = [None] * (cols + 1)  # место в памяти для рабочей строки
    for row_idx in range(1, rows + 1):

        prev_row = cur_row
        cur_row = btm_row
        cur_row = [row_idx] + [0] * cols

        for col_idx in range(1, cols + 1):
            add, delete, change = (
                prev_row[col_idx] + 1,
                cur_row[col_idx - 1] + 1,
                prev_row[col_idx - 1]
            )
            if string_one[col_idx - 1] != string_two[row_idx - 1]:
                change += 1
            cur_row[col_idx] = min(add, delete, change)

    return cur_row[col_idx]


def main():
    with open('input.txt') as file_in:
        first_string = file_in.readline()
        second_string = file_in.readline()
        file_in.close()

    print(get_levenshtein(first_string, second_string))


if __name__ == '__main__':
    main()
