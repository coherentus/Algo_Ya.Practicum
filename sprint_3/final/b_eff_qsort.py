# https://contest.yandex.ru/contest/23815/run-report/65645694/
# Задача Б. Быстрая ортировка 'на месте' (in-place quick sort).
# Необходимо реализовать рекурсивный алгоритм быстрой сортировки
# без использования дополнительной памяти.
#
# Сортируемые эл-ты состоят из трёх раличных значений. Строки и двух чисел.
# Строка означает логин, а числа - кол-во решённых задач и штраф.
# Приоритеты сортировки:
# 1. кол-во решённых задач. По убыванию, т.е. на первом месте - max.
# 2. для равных п.1 штраф вступает в сортировку. По возрастанию, min выше.
# 3. для равных п.2 логин вступает в сортировку. По алфавиту из строчных
# латинских букв.
#
# Формат ввода
# В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
# В каждой из следующих n строк задана информация про одного из участников.
# i-й участник описывается тремя параметрами:
#
# уникальным логином (строкой из маленьких латинских букв длиной до 20)
# числом решённых задач Pi
# штрафом Fi
# Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10**9.
# Формат вывода
# Для отсортированного списка участников вывести по порядку их логины
# по одному в строке.
#
# -- ПРИНЦИП РАБОТЫ --
# В Python есть встроенная операция сравнения однотипных списков,
# числа сравниваются как обычно, а строки лексикографически посимвольно.
# 1. Чтобы воспользоваться операцией сравнения необходимо на этапе ввода
# определённым образом сформировать исходный массив:
# строка на входе
# логин           баллы за задачи         баллы штрафа
#
# в массив попадает в виде
# points                          penalty                 name
# int((баллы за задачи) * -1)     int(баллы штрафа)       логин
#
# В таком виде введённые данные позволяют использовать операцию сравнения
# для оговоренной в задании логикой сортировки.
# 2. Сама сортировка. 
# Алгоритм рекурсивной функции следующий:
# На входе массив (ссылка на него) и начальный и конечный индексы.
# 1. Проверка базового случая. Если наступил - возврат из функции.
# 2. Выбор опорного эл-та (pivot). Берётся значение эл-та из середины
# диапазона, заданного входными знчениями left right.
# 3. Создание левого и правого указателей left_idx right_idx. С их помощью
# будут сравниваться и меняться местами эл-ты.
# 4. Запуск переборки эл-тов.
# Пока левый и правый указатели не встретятся производятся переборы значений
# слева и справа от опорного. 
# С левого края (от меньших индексов) вправо последовательно сравниваются
# значения эл-тов с опорным. Если найден эл-т больше опорного, он становится
# кандидатом на перемещение в правую часть. Перебор приостанавливается.
# С правого края (от больших индексов) влево последовательно сравниваются
# значения эл-тов с опорным. Если найден эл-т меньше опорного, он становится
# кандидатом на перемещение в левую часть. Перебор приостанавливается.
# По остановке обоих указателей возможны три варианта:
# а) Кандидатов не нашлось. Левый и правый указатели равны.
# Передаче в следующие итерации подлежат отрезки
# [left, right_idx] и [left_idx, right]. Проверка (left_idx <= right_idx)
# отсекает перемещение эл-тов и закрывает цикл переборки указателей.
# б) С обеих сторон нашлись кандидаты. Левый и правый указатели указывают
# на них. Следует поменять значения кандидатов местами.
# Проверка (left_idx <= right_idx) запускает это действие. После этого
# циклы поиска кандидатов продолжаются.
# в) Кандидат нашёлся только с одной стороны. Указатели указывают, один на
# кандидата, второй на pivot. Необходимо поменять местами значения pivot и
# кандидата. Проверка (left_idx <= right_idx) запускает это действие.
# После этого циклы поиска кандидатов продолжаются.
#
# 3. Вывод результата.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Согласно условию задания рекурсивная функция сортировки на каждой итерации
# вызывается с аргументами из индексов во внешнем для неё массиве.
# В процессе работы алгоритм занимается сравнением и в случае необходимости
# перестановкой эл-тов в этом массиве. Новых массивов из частей исходного
# не создаётся.
# За опорный выбирается средний по расположению эл-т.
# За базовый случай принят вариант, когда в очередную итерацию передан
# массив из одного эл-та или пустой. Проверка (if right <= left) в начале
# функции это отслеживает и обеспечивает корректное "всплытие" из рекурсии.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность быстрой сортировки в худшем случае - O(N^2),
# но в среднем принимается О(Nlog N), где N - размер массива.
# Пространственная сложность - O(1) для самой функции
# и O(N) для всей программы с вводом данных.
def qsort(arr, left, right):
    """Сортировка массива по трём составлющим 'на месте'.

    Args:
        arr (list[[int, int, str],...]): -Баллы, штраф, имя.
        left (int): левый индекс диапазона
        right (int): правый индекс диапазона
    """
    if right <= left:
        return
    left_idx = left
    right_idx = right

    pivot = (left + right) // 2
    reference = arr[pivot]
    while left_idx <= right_idx:
        while reference > arr[left_idx]:
            left_idx += 1
        while reference < arr[right_idx]:
            right_idx -= 1
        if left_idx <= right_idx:
            arr[left_idx], arr[right_idx] = arr[right_idx], arr[left_idx]
            left_idx += 1
            right_idx -= 1

    qsort(arr, left, right_idx)
    qsort(arr, left_idx, right)


def get_order(players):
    """Запуск сортировки и возврат требуемых значений.

    Args:
        players (list[[int, int, str],...]) - Баллы, штраф, имя.
    Returns:
        result (list[str]) - Имя.
    """
    qsort(players, 0, len(players) - 1)
    return [row[2] for row in players]


def main():
    count_line = int(input())
    persons = [None] * count_line
    for i in range(count_line):
        name, points, penalty = input().split()
        # формирование массива для удобства сравнения
        persons[i] = (-int(points), int(penalty), name)

    result = get_order(persons)
    print(*result, sep='\n')


if __name__ == '__main__':
    main()
