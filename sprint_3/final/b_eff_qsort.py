# https://contest.yandex.ru/contest/23815/run-report/65497570/
#  Задача Б. Быстрая ортировка 'на месте' (in-place quick sort).
# Необходимо реализовать рекурсивный алгоритм быстрой сортировки
# без использования дополнительной памяти.
# 
# Сортируемые эл-ты состоят из трёх раличных значений. Строки и двух чисел.
# Строка означает логин, а числа - кол-во решённых задач и штраф.
# Приоритеты сортировки:
# 1. кол-во решённых задач. По убыванию, т.е. на первом месте - max.
# 2. для равных п.1 штраф вступает в сортировку. По возрастанию, min выше.
# 3. для равных п.2 логин вступает в сортировку. По алфавиту из строчных
# латинских букв.
# 
# Формат ввода
# В первой строке задано число участников n, 1 ≤ n ≤ 100 000.
# В каждой из следующих n строк задана информация про одного из участников.
# i-й участник описывается тремя параметрами:
# 
# уникальным логином (строкой из маленьких латинских букв длиной не до 20)
# числом решённых задач Pi
# штрафом Fi
# Fi и Pi — целые числа, лежащие в диапазоне от 0 до 10**9.
# Формат вывода
# Для отсортированного списка участников вывести по порядку их логины
# по одному в строке.
#
# -- ПРИНЦИП РАБОТЫ --
# В Python есть встроенная операция сравнения однотипных списков,
# числа сравниваются как обычно, а строки лексикографически посимвольно.
# 1. Чтобы воспользоваться операцией сравнения необходимо на этапе ввода
# определённым образом сформировать исходный массив:
# строка на входе
# логин           баллы за задачи         баллы штрафа
#
# в массив попадает в виде
# points                          penalty                 name
# int((баллы за задачи) * -1)     int(баллы штрафа)       логин
#
# В таком виде введённые данные позволяют использовать операцию сравнения
# для оговоренной в задании логикой сортировки. 
# 2. Сама сортировка. Алгоритм подробно расписан в задании
# https://contest.yandex.ru/contest/23815/problems/B/
# необходима лишь внимательная реализация.
# 3. Вывод результата.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Согласно условию задания рекурсивная функция сортировки на каждой итерации
# вызывается с аргументами из индексов во внешнем для неё массиве.
# В процессе работы алгоритм занимается сравнением и в случае необходимости
# перестановкой эл-тов в этом массиве. Новых массивов из частей исходного
# не создаётся.
# За опорный выбирается средний по расположению эл-т.
# За базовый случай принят момент равенства левого и правого указателей или
# перехода правого левее левого(левого правее правого).

# -- ОЦЕНКА СЛОЖНОСТИ --
# Временная сложность быстрой сортировки в худшем случае - O(N^2),
# но в среднем принимается О(Nlog N), где N - размер массива.
# Пространственная сложность - O(1) для самой функции
# и O(N) для всей программы с вводом данных.
def qsort(arr, left, right):
    """Сортировка массива по трём составлющим 'на месте'.

    Args:
        arr (list[[int, int, str],...]): -Баллы, штраф, имя.
        left (int): левый индекс диапазона
        right (int): правый индекс диапазона
    """
    if right <= left:
        return
    left_idx = left
    right_idx = right

    pivot = (left + right) // 2
    reference = arr[pivot]
    while left_idx <= right_idx:
        while reference > arr[left_idx]:
            left_idx += 1
        while reference < arr[right_idx]:
            right_idx -= 1
        if left_idx <= right_idx:
            arr[left_idx], arr[right_idx] = arr[right_idx], arr[left_idx]
            left_idx += 1
            right_idx -= 1

    qsort(arr, left, right_idx)
    qsort(arr, left_idx, right)


def get_order(players):
    """Запуск сортировки и возврат требуемых значений.

    Args:
        players (list[[int, int, str],...]) - Баллы, штраф, имя.
    Returns:
        result (list[str]) - Имя.
    """
    qsort(players, 0, len(players) - 1)
    return [row[2] for row in players]


def main():
    count_line = int(input())
    persons = [None] * count_line
    for i in range(count_line):
        name, points, penalty = input().split()
        # формирование массива для удобства сравнения
        persons[i] = (-int(points), int(penalty), name)

    result = get_order(persons)
    print(*result, sep='\n')


if __name__ == '__main__':
    main()
