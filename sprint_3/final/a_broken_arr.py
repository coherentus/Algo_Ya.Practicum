# https://contest.yandex.ru/contest/23815/run-report/65634952/
# Задача А. Поиск в сломанном массиве.
# Изначально есть упорядоченный по возрастанию массив уникальных
# натуральных чисел.
# Затем к нему применяется операция кольцевого сдвига, то есть значение
# крайнего эл-та запоминается в другом месте, на его место перемещается
# значение соседнего эл-та и так до конца массива. На последнее
# освободившееся место вписывается ранее сохранённое значение
# крайнего эл-та.
# Количество шагов сдвига и напрвление произвольны.
# Для полученного "сломанного" массива необходимо написать функцию поиска
# заданного заначения с временной сложностью не хуже О(log n),
# где n - длина массива.
#
# -- ПРИНЦИП РАБОТЫ --
# Для получения временной сложности О(log n) стоит использовать принцип
# бинарного поиска, а именно: разбиение на две части и определение,
# в какой из них икать дальше.
# Образно говоря, входной массив представляет собой последовательность
# возрастающих чисел. Где-то в нём может быть "ступенька" из максимального
# эл-та и следующего за ним минимального. После "ступеньки" массив снова
# выглядит как последовательность возрастающих чисел.
# Разбивая массив на части посередине мы получим или обе части
# отсортированными, если попали на ступеньку, или одну часть сортированной,
# а вторую - со ступенькой внутри.
# Так как, по условию эл-ты массива уникальны, можно легко определить,
# сортирована ли часть, сравнивая её крайние эл-ты.
# Затем, для сортированной части легко определить, попадает ли в неё
# искомый эл-т. В этом случае вызывается функция бинпоиска на интервале
# массива, использующая модуль bisect.
# Если по итогам итерации не определено, что X входит в отсортированную
# то в следующую итерацию передаются индексы несортированной части.
#
# -- ДОКАЗАТЕЛЬСТВО КОРРЕКТНОСТИ --
# Работа данного алгоритма основана на уникальности элементов. Без этого
# условия нельзя однозначно определить сортированность части и исключить из
# далнейшего просмотра её или другую.
#
# -- ОЦЕНКА СЛОЖНОСТИ --
# Так как для нахождения эл-та используется принцип бинарного поиска,
# то временная сложность составит О(log N), где N - размер массива.
# Пространственная сложность - О(1), так как для работы алгоритма
# использованы всего три дополнительные переменные и их число
# постоянно и не зависит от размера массива.
import bisect


def std_binsearch(arr, left_idx, right_idx, value):
    """Найти бинпоиском позицию эл-та в массиве и вернуть её или -1.

    Args:
        arr : массив однотипных эл-тов
        left_idx (int): начальный индекс в массиве
        right_idx (int): конечный индекс в массиве
        value : искомое значение

    Returns:
        int: индекс, если эл-т есть в массиве
             -1 в противном случае
    Фукция bisect_left() модуля bisect возвращает индекс левой позиции
    по которой эл-т с переданным значением может быть вставлен
    в отсортированный массив. Проверкой выявляется, находится ли по
    найденному индексу искомое значение.
    """
    val_index = bisect.bisect_left(arr, value, lo=left_idx, hi=right_idx)
    if val_index != right_idx and arr[val_index] == value:
        return val_index
    return -1


def broken_search(nums, target) -> int:
    """Бинарный поиск в 'сломанном' списке.

    Args:
        nums (List): массив, бывший отсортированным в кольцевой структуре
        target ([type]): искомый эл-т
    Returns:
        int: индекс искомого эл-та, или -1 если не найден
    Алгоритм поиска:
    Массив делится на две части посередине.
    Одна точно должна быть упорядоченна.
    Если часть отсортирована, легко проверяется, входит ли в неё X.
    Итого:
    За left, right берутся индексы первого и последнего эл-тов.
    В цикле пока диапазон не схлопнется:
    Делим на части.
    Проверяем mid == X.
    Если левая сортирована:
        если X входит:
            вызов тривиального бинпоиска на интервале массива
        иначе:
            индексы правой для след. итерации
    иначе:
        если X входит:
            вызов тривиального бинпоиска на интервале массива
        иначе:
            индексы левой для след. итерации
    след. итерация
    При сужении диапазона до двух эл-тов, проверка на сортированность
    сравнивает один и тот же эл-т с собой. В условии необходимо '='.
    """
    left, right = 0, len(nums) - 1

    while left <= right:
        mid = (left + right) // 2
        if nums[mid] == target:
            return mid

        # левая часть
        if nums[left] <= nums[mid]:
            if nums[left] <= target < nums[mid]:
                # right = mid - 1
                return std_binsearch(nums, left, mid, target)
            else:
                left = mid + 1
        else:  # правая часть
            if nums[mid] < target <= nums[right]:
                return std_binsearch(nums, mid, right + 1, target)
            else:
                right = mid - 1
    return -1
